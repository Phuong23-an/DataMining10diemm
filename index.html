<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trắc Nghiệm Lập Trình Mạng</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: white;
            border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        header {
            background: linear-gradient(90deg, #2c3e50, #4a6fa5);
            color: white;
            padding: 25px 30px;
            text-align: center;
            border-bottom: 5px solid #3498db;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }

        .subtitle {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .quiz-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 1px solid #dee2e6;
        }

        .info-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
            color: #2c3e50;
            padding: 10px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 3px 10px rgba(0,0,0,0.08);
        }

        .info-item i {
            color: #3498db;
            font-size: 1.2rem;
        }

        .controls-panel {
            padding: 20px;
            background: #e8f4fc;
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            border-bottom: 1px solid #c3d7ea;
        }

        .btn {
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.95rem;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn-toggle {
            background: #6c757d;
            color: white;
        }

        .btn-toggle.active {
            background: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.3);
        }

        .btn-toggle.shuffle {
            background: #ffc107;
            color: #212529;
        }

        .btn-toggle.shuffle.active {
            background: #e0a800;
        }

        .btn-retry {
            background: #dc3545;
            color: white;
        }

        .btn-retry.active {
            background: #6c757d;
            box-shadow: 0 0 0 3px rgba(108, 117, 125, 0.3);
        }

        .btn-nav {
            background: #3498db;
            color: white;
            flex: 1;
            min-width: 150px;
            justify-content: center;
        }

        .btn-nav:disabled {
            background: #a0c4ff;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .question-container {
            padding: 30px;
            min-height: 400px;
            display: flex;
            flex-direction: column;
        }

        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e9ecef;
        }

        .question-number {
            font-size: 1.4rem;
            color: #4a6fa5;
            display: flex;
            align-items: center;
            gap: 10px;
            font-weight: 600;
        }

        .retry-mode-badge {
            background: #dc3545;
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-size: 0.8rem;
            margin-left: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        /* THÊM PHẦN CODE CONTAINER */
        .code-container {
            background: #2d2d2d;
            color: #f8f8f2;
            border-radius: 8px;
            padding: 20px;
            margin: 15px 0;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            overflow-x: auto;
            white-space: pre-wrap;
            word-break: break-word;
            tab-size: 4;
            border-left: 4px solid #3498db;
        }

        .code-container .line-number {
            color: #888;
            margin-right: 15px;
            user-select: none;
        }

        .code-container .keyword {
            color: #c678dd;
        }

        .code-container .string {
            color: #98c379;
        }

        .code-container .class {
            color: #e5c07b;
        }

        .code-container .method {
            color: #61afef;
        }

        .code-container .comment {
            color: #5c6370;
        }

        .code-container .number {
            color: #d19a66;
        }

        /* THÊM STYLE CHO HÌNH ẢNH */
        .question-image {
            max-width: 100%;
            height: auto;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #e0e0e0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .image-caption {
            text-align: center;
            font-style: italic;
            color: #6c757d;
            margin-bottom: 20px;
            font-size: 0.9rem;
            padding: 5px 0;
        }

        .question-text {
            font-size: 1.3rem;
            line-height: 1.8;
            margin-bottom: 20px;
            color: #2c3e50;
            font-weight: 600;
        }

        .question-content {
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #3498db;
            white-space: pre-line;
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
            margin-bottom: 30px;
        }

        .option {
            padding: 20px;
            border: 2px solid #dee2e6;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 15px;
            position: relative;
            overflow: hidden;
        }

        .option:hover {
            background: #f0f7ff;
            border-color: #a0c4ff;
            transform: translateX(10px);
        }

        .option.selected {
            background: #d1ecf1;
            border-color: #17a2b8;
            color: #0c5460;
        }

        .option.correct {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border-color: #28a745;
            color: #155724;
            animation: correctPulse 0.6s ease;
        }

        .option.incorrect {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            border-color: #dc3545;
            color: #721c24;
            animation: incorrectShake 0.6s ease;
        }

        @keyframes correctPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.02); }
            100% { transform: scale(1); }
        }

        @keyframes incorrectShake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }

        .option-label {
            min-width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #e9ecef;
            border-radius: 50%;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .option.correct .option-label {
            background: #28a745;
            color: white;
            box-shadow: 0 0 15px rgba(40, 167, 69, 0.5);
        }

        .option.incorrect .option-label {
            background: #dc3545;
            color: white;
            box-shadow: 0 0 15px rgba(220, 53, 69, 0.5);
        }

        .option-text {
            flex: 1;
            font-size: 1.1rem;
        }

        .status-icon {
            font-size: 1.3rem;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .option.correct .status-icon {
            opacity: 1;
            color: #28a745;
        }

        .option.incorrect .status-icon {
            opacity: 1;
            color: #dc3545;
        }

        .feedback {
            margin-top: 20px;
            padding: 20px;
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            border-radius: 8px;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .feedback h4 {
            color: #856404;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .progress-container {
            margin: 20px 0;
            padding: 0 30px;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 6px;
        }

        .progress-text {
            display: flex;
            justify-content: space-between;
            margin-top: 8px;
            font-weight: 600;
            color: #495057;
        }

        .navigation {
            padding: 20px 30px;
            display: flex;
            gap: 15px;
            background: #f8f9fa;
            border-top: 1px solid #dee2e6;
        }

        .result-container {
            padding: 40px;
            text-align: center;
            display: none;
        }

        .result-container.show {
            display: block;
            animation: fadeIn 0.5s ease;
        }

        .result-header {
            font-size: 2.5rem;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .score {
            font-size: 4rem;
            font-weight: bold;
            color: #4a6fa5;
            margin: 30px 0;
            text-shadow: 3px 3px 0 rgba(0,0,0,0.1);
        }

        .score-text {
            font-size: 1.5rem;
            color: #6c757d;
            margin-bottom: 40px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .stat-item {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: bold;
            color: #3498db;
        }

        .stat-label {
            color: #6c757d;
            margin-top: 10px;
        }

        footer {
            text-align: center;
            padding: 20px;
            color: #6c757d;
            font-size: 0.9rem;
            border-top: 1px solid #dee2e6;
        }

        @media (max-width: 768px) {
            .container {
                border-radius: 15px;
            }
            
            h1 {
                font-size: 1.8rem;
                flex-direction: column;
                gap: 10px;
            }
            
            .quiz-info {
                grid-template-columns: 1fr;
            }
            
            .controls-panel {
                justify-content: center;
            }
            
            .btn {
                width: 100%;
                justify-content: center;
            }
            
            .navigation {
                flex-direction: column;
            }
            
            .question-text {
                font-size: 1.1rem;
                padding: 15px;
            }
            
            .option {
                padding: 15px;
            }
            
            .score {
                font-size: 3rem;
            }
            
            .code-container {
                font-size: 12px;
                padding: 15px;
            }
            
            .question-image {
                max-width: 95%;
            }
        }

        /* Hiệu ứng loading */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 200px;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <i class="fas fa-brain"></i>
                Trắc Nghiệm Data Mining
            </h1>
            <p class="subtitle">Ôn tập kiến thức Data Mining</p>
        </header>

        <div class="quiz-info">
            <div class="info-item">
                <i class="fas fa-question-circle"></i>
                <div>
                    <div>Câu hiện tại</div>
                    <div id="current-question">1/95</div>
                </div>
            </div>
            <div class="info-item">
                <i class="fas fa-check-circle"></i>
                <div>
                    <div>Đã trả lời</div>
                    <div id="answered-count">0/95</div>
                </div>
            </div>
            <div class="info-item">
                <i class="fas fa-star"></i>
                <div>
                    <div>Điểm số</div>
                    <div id="score">0</div>
                </div>
            </div>
            <div class="info-item">
                <i class="fas fa-chart-line"></i>
                <div>
                    <div>Tiến độ</div>
                    <div id="progress-percent">0%</div>
                </div>
            </div>
        </div>

        <div class="controls-panel">
            <button id="auto-next-btn" class="btn btn-toggle active">
                <i class="fas fa-bolt"></i>
                <span>Tự chuyển câu (BẬT)</span>
            </button>
            <button id="shuffle-questions-btn" class="btn btn-toggle shuffle">
                <i class="fas fa-random"></i>
                <span>Đảo câu hỏi</span>
            </button>
            <button id="shuffle-options-btn" class="btn btn-toggle">
                <i class="fas fa-list-ol"></i>
                <span>Đảo đáp án</span>
            </button>
            <button id="retry-wrong-btn" class="btn btn-retry">
                <i class="fas fa-redo-alt"></i>
                <span>Làm lại câu sai</span>
            </button>
        </div>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text">
                <span>Bắt đầu</span>
                <span id="progress-text">0%</span>
                <span>Hoàn thành</span>
            </div>
        </div>

        <div id="quiz-content">
            <div class="loading">
                <div class="spinner"></div>
            </div>
        </div>

        <div class="navigation">
            <button id="prev-btn" class="btn btn-nav" disabled>
                <i class="fas fa-arrow-left"></i>
                Câu trước
            </button>
            <button id="next-btn" class="btn btn-nav">
                Câu sau
                <i class="fas fa-arrow-right"></i>
            </button>
            <button id="result-btn" class="btn btn-nav" style="background: #ffc107; color: #212529; display: none;">
                <i class="fas fa-chart-bar"></i>
                Xem kết quả
            </button>
        </div>

        <div id="result-container" class="result-container">
            <h2 class="result-header">
                <i class="fas fa-trophy"></i>
                Kết Quả Bài Làm
            </h2>
            
            <div class="score" id="final-score">0/95</div>
            
            <div class="score-text" id="score-text">Đang tính toán...</div>
            
            <div class="result-stats">
                <div class="stat-item">
                    <div class="stat-value" id="stat-correct">0</div>
                    <div class="stat-label">Câu đúng</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-wrong">0</div>
                    <div class="stat-label">Câu sai</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-skipped">0</div>
                    <div class="stat-label">Chưa làm</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="stat-percentage">0%</div>
                    <div class="stat-label">Tỷ lệ đúng</div>
                </div>
            </div>
            
            <div style="margin-top: 40px; display: flex; gap: 15px; justify-content: center;">
                <button id="restart-btn" class="btn" style="background: #28a745; color: white;">
                    <i class="fas fa-redo"></i>
                    Làm lại
                </button>
                <button id="review-btn" class="btn" style="background: #17a2b8; color: white;">
                    <i class="fas fa-search"></i>
                    Xem chi tiết
                </button>
            </div>
        </div>

        <footer>
            <p>© 2025 - Ôn tập Data Mining </p>
            <p style="margin-top: 5px; font-size: 0.8rem;">Nhấn F5 để làm lại từ đầu</p>
        </footer>
    </div>

    <script>
        // ========== HÀM XỬ LÝ CODE JAVA ==========
        const highlightJavaCode = (code) => {
            // Thay thế các từ khóa Java với span có class
            let highlighted = code
                .replace(/\b(try|catch|finally|throw|throws|new|class|interface|extends|implements|public|private|protected|static|final|void|int|long|float|double|char|byte|short|boolean|if|else|while|do|for|switch|case|default|break|continue|return|import|package)\b/g, 
                    '<span class="keyword">$1</span>')
                .replace(/\b([A-Z][a-zA-Z0-9]*)\b/g, 
                    '<span class="class">$1</span>')
                .replace(/\b(get[A-Z][a-zA-Z0-9]*|set[A-Z][a-zA-Z0-9]*|[a-z][a-zA-Z0-9]*)\(/g, 
                    '<span class="method">$1</span>(')
                .replace(/"(.*?)"/g, 
                    '<span class="string">"$1"</span>')
                .replace(/\b(\d+)\b/g, 
                    '<span class="number">$1</span>')
                .replace(/\/\/.*$/gm, 
                    '<span class="comment">$&</span>')
                .replace(/\/\*[\s\S]*?\*\//g, 
                    '<span class="comment">$&</span>');
            
            // Thêm số dòng cho code có số dòng (1., 2., 3., ...)
            if (code.includes('1.')) {
                const lines = highlighted.split('\n');
                highlighted = lines.map((line, index) => {
                    const trimmed = line.trim();
                    if (trimmed.match(/^\d+\./)) {
                        return `<span class="line-number">${trimmed.substring(0, trimmed.indexOf(' '))}</span>${line.substring(trimmed.indexOf(' '))}`;
                    }
                    return line;
                }).join('\n');
            }
            
            return highlighted;
        };

        // ========== DỮ LIỆU CÂU HỎI (CÓ THỂ THÊM HÌNH ẢNH) ==========
       const allQuestions= [
    {
        question: "Câu 1: Data Mining được định nghĩa là gì?",
        options: [
            "Là một quy trình tìm kiếm, phát hiện các tri thức mới, tiềm ẩn, hữu dụng trong cơ sở dữ liệu lớn",
            "Khai phá dữ liệu",
            "Khai khoáng dữ liệu",
            "Tìm kiếm thông tin trên Internet"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 2: Thuật ngữ Data Mining dịch ra tiếng Việt có nghĩa là:",
        options: [
            "Khai phá dữ liệu hoặc Khai thác dữ liệu",
            "Khai phá luật kết hợp",
            "Khai phá tập mục thường xuyên",
            "Khai phá tri thức từ dữ liệu lớn"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 3: Thuật ngữ Knowledge Discovery from Databases (KDD) có nghĩa là:",
        options: [
            "Trích chọn các mẫu hoặc tri thức hấp dẫn (không tầm thường, ẩn, chưa biết và hữu dụng tiềm năng) từ tập dữ liệu lớn",
            "Khai phá dữ liệu",
            "Khai thác dữ liệu",
            "Tìm kiếm dữ liệu"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 4: Phát biểu nào sau đây là đúng?",
        options: [
            "Data Mining là một bước trong quá trình khai phá tri thức - KDD",
            "Thuật ngữ Data Mining đồng nghĩa với Knowledge Discovery from Databases",
            "Data Mining là quá trình tìm kiếm thông tin có ích trên Internet",
            "Tiền xử lí dữ liệu là quá trình tìm kiếm thông tin có ích từ cơ sở dữ liệu lớn"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 5: Hiện nay, Data Mining đã được ứng dụng trong:",
        options: [
            "Hệ quản trị CSDL SQL Server",
            "Hệ quản trị CSDL Access",
            "Hệ quản trị CSDL Foxpro",
            "Microsoft Word 2010"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 6: Thuật ngữ Tiền xử lí dữ liệu bằng tiếng Anh là:",
        options: [
            "Data Preprocessing",
            "Data Processing",
            "Preprocessing in Database",
            "Data Process"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 7: Cho CSDL giao tác như hình vẽ. Số lượng giao dịch trong cơ sở dữ liệu là:",
image: "images/7.jpg",
imageCaption: "",
        options: [
            "5",
            "16",
            "6",
            "10"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 8: Cho CSDL giao dịch như hình vẽ. Độ hỗ trợ của tập mục X = {A, M} là:",
        image: "images/8.jpg",
        imageCaption: "",
        options: [
            "3 (60%)",
            "4 (80%)",
            "5 (100%)",
            "2 (40%)"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 9: Thuật toán Apriori có nhược điểm chính là:",
        options: [
            "Tốn nhiều bộ nhớ và thời gian. Không thích hợp với các mẫu lớn. Chi phí để duyệt CSDL nhiều",
            "Không tìm được các tập mục thường xuyên",
            "Kết quả không ứng dụng được trong thực tế",
            "Thuật toán quá phức tạp, khó hiểu"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 10: Cho CSDL giao dịch với Min_Support = 2 (50%). Tập nào là tập mục thường xuyên thỏa Min_support:",
        image: "images/10.jpg",
        imageCaption: "",
        options: [
            "{A, C}",
            "{D}",
            "{A, D}",
            "{B, C, D}"
        ],
        correctAnswer: 0
    },
{
        question: "Câu 11: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Tập nào không là tập mục thường xuyên?",
        image: "images/11.jpg",
        imageCaption: "",
        options: [
            "{A, C, D}",
            "{A, E}",
            "{A, C}",
            "{B, E}"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 12: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Tập nào không là tập mục thường xuyên?",
        image: "images/12.jpg",
        imageCaption: "",
        options: [
            "{D}",
            "{A, E}",
            "{A, C}",
            "{B, E}"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 13: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Sử dụng thuật toán Apriori, sau lần duyệt thứ nhất, tập mục chứa 1-item bị loại bỏ là:",
        image: "images/13.jpg",
        imageCaption: "",
        options: [
            "{D}",
            "{A}",
            "{B}",
            "{A}, {D}"
        ],
        correctAnswer: 3
    },
    {
        question: "Câu 14: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Tập nào không là tập mục thường xuyên?",
        image: "images/14.jpg",
        imageCaption: "",
        options: [
            "{B, D}",
            "{A, E}",
            "{A, C}",
            "{B, E}"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 15: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Tập nào là tập mục thường xuyên với độ hỗ trợ là 75%?",
        image: "images/15.jpg",
        imageCaption: "",
        options: [
            "{B, E}",
            "{A, E}",
            "{A, C}",
            "{B, C}"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 16: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Tập nào là tập mục thường xuyên với độ hỗ trợ = 70%?",
        image: "images/16.jpg",
        imageCaption: "",
        options: [
            "Không có tập nào",
            "{A, E}",
            "{A, C, D}",
            "{B, C, D}"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 17: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%), Min_Confidence = 50%. Luật kết hợp nào thỏa mãn các điều kiện đã cho?",
        image: "images/17.jpg",
        imageCaption: "",
        options: [
            "A --> C",
            "A --> D",
            "A --> E",
            "AB --> C"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 18: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%), Min_Confidence = 50%. Luật kết hợp nào thỏa mãn các điều kiện đã cho?",
        image: "images/18.jpg",
        imageCaption: "",
        options: [
            "B --> E",
            "A --> D",
            "A --> E",
            "AB --> C"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 19: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%), Min_Confidence = 50%. Luật kết hợp nào thỏa mãn các điều kiện đã cho?",
        image: "images/19.jpg",
        imageCaption: "",
        options: [
            "A --> C",
            "A --> D",
            "A --> E",
            "AB --> C"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 20: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%), Min_Confidence = 50%. Luật kết hợp nào có độ tin cậy = 100%?",
        image: "images/20.jpg",
        imageCaption: "",
        options: [
            "A --> C",
            "A --> D",
            "AD --> E",
            "AB --> C"
        ],
        correctAnswer: 0
    },
{
        question: "Câu 21: Cho tập mục thường xuyên X = {A, B}, từ tập X có thể sinh ra các luật kết hợp sau:",
        options: [
            "A --> B, B --> A, không tính luật AB --> ∅ và ∅ --> AB",
            "A --> B, B --> A, A --> ∅ và ∅ --> B",
            "A --> B",
            "B --> A"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 22: Cho FP-Tree như hình vẽ, có mấy đường đi kết thúc ở nút m?",
        image: "images/22.jpg",
        imageCaption: "",
        options: [
            "2 đường đi",
            "1 đường đi",
            "3 đường đi",
            "4 đường đi"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 23: Cho FP-Tree như hình vẽ, có mấy đường đi kết thúc ở nút p?",
        image: "images/23.jpg",
        imageCaption: "",
        options: [
            "2 đường đi",
            "1 đường đi",
            "3 đường đi",
            "4 đường đi"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 24: Hai thuật toán FP-Growth và Apriori dùng để:",
        options: [
            "Tìm các tập mục thường xuyên",
            "Tìm các luật kết hợp",
            "Tìm các tập mục có k-item",
            "Thực hiện công việc khác"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 25: Phương pháp nào không phải là phương pháp phân lớp?",
        options: [
            "Chia các đối tượng thành từng lớp để giảng dạy",
            "Phân lớp dựa trên Cây quyết định",
            "Phân lớp dựa trên xác suất Bayes",
            "Phân lớp dựa trên Mạng Nơron"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 26: Cho tập ví dụ học như bảng. Có bao nhiêu thuộc tính để phân lớp?",
        image: "images/26.jpg",
        imageCaption: "",
        options: [
            "4 thuộc tính",
            "3 thuộc tính",
            "5 thuộc tính",
            "6 thuộc tính"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 27: Cho tập ví dụ học như bảng. Thuộc tính kết luận Play Ball có bao nhiêu giá trị?",
        image: "images/27.jpg",
        imageCaption: "",
        options: [
            "2 giá trị",
            "3 giá trị",
            "5 giá trị",
            "1 giá trị"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 28: Cho tập ví dụ học như bảng. Các thuộc tính dùng để phân lớp là:",
        image: "images/28.jpg",
        imageCaption: "",
        options: [
            "Outlook, Temperature, Humidity, Wind",
            "Outlook, Temperature, Humidity, Wind, Play Ball",
            "Day, Outlook, Temperature, Humidity, Wind",
            "Day, Outlook, Temperature, Humidity, Wind, Play Ball"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 29: Khi chọn một thuộc tính A để làm gốc cây quyết định, nếu thuộc tính A có 3 giá trị thì cây quyết định có bao nhiêu nhánh?",
        options: [
            "3 nhánh",
            "2 nhánh",
            "Nhiều nhánh",
            "Phải biết kết luận C có bao nhiêu giá trị thì mới phân nhánh được"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 30: Sử dụng thuật toán ILA, khi kết luận C có n giá trị thì ta cần chia bảng chứa các ví dụ học thành mấy bảng con?",
        options: [
            "n bảng con",
            "2 bảng con",
            "Không phải chia",
            "Thành nhiều bảng tùy theo giá trị của n"
        ],
        correctAnswer: 0
    },
{
        question: "Câu 31: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA, cần chia bảng ví dụ học này thành mấy bảng con?",
        image: "images/31.jpg",
        imageCaption: "",
        options: [
            "2 bảng",
            "3 bảng",
            "Không cần chia",
            "Tùy theo thuộc tính được chọn"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 32: Cho giá trị của A là 3500. Sử dụng phương pháp chuẩn hóa Tỷ lệ Thập phân decimal scale, giá trị của A sau khi chuẩn hóa là:",
        options: [
            "0.35",
            "3.5",
            "0.015",
            "Giá trị khác"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 33: ID3 sử dụng hàm nào để xác định thuộc tính làm gốc phân nhánh trong quá trình xây dựng cây quyết định?",
        options: [
            "Entropy và Gain",
            "Entropy",
            "Gain",
            "Gain Ratio"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 34: Đường kính của cụm được định nghĩa là khoảng cách giữa 2 phần tử xa nhau nhất trong cùng 1 cụm. Cho 1 cụm gồm các phần tử C={x1, x2, x3, x4} với x1(0,0), x2(1,0), x3(6,0), x4(10, 0) ",
        options: [
            "d = 10",
            "d = 4",
            "d = 6",
            "d = 1"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 35: Cho miền giá trị của A từ -186 đến 917. Sử dụng phương pháp chuẩn hóa Tỷ lệ Thập phân decimal scale, miền giá trị của A sau khi chuẩn hóa là:",
        options: [
            "-0.186 đến 0.917",
            "0.0 đến 1.0",
            "0.0 đến 9.17",
            "Giá trị khác"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 36: Gom cụm (Clustering) là gì?",
        options: [
            "Phân cụm dữ liệu(Data Clustering) hay phân cụm, cũng có thể gọi là phân tích cụm là qúa trình chia một tập các đối tượng thực thể hay trừu tượng thành nhóm các đối tượng sao cho các phần tử trong cùng một nhóm thì có mức độ tương tự nhau hơn là giữa các phần tử của nhóm này với các phần tử của nhóm khác. ",
            "Phân cụm dữ liệu(Data Clustering) hay phân cụm, cũng có thể gọi là phân tích cụm là qúa trình chia một tập các đối tượng thực thể hay trừu tượng thành nhóm các đối tượng sao cho các phần tử khác nhóm thì có mức độ tương tự nhau hơn là giữa các phần tử trong cùng một nhóm",
            "Phân cụm dữ liệu(Data Clustering) hay phân cụm, cũng có thể gọi là phân tích cụm là qúa trình chia một tập các đối tượng thực thể hay trừu tượng thành nhóm các đối tượng sao dễ sử dụng nhất. ",
            "d.	Phân cụm dữ liệu(Data Clustering) hay phân cụm, cũng có thể gọi là phân tích cụm là qúa trình chia các đối tượng thành từng nhóm sau cho số nhóm là ít nhất."
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 37: Thuật ngữ tiếng Anh nào có nghĩa là phân cụm dữ liệu?",
        options: [
            "Data Clustering",
            "Data Classification",
            "Association Rule",
            "Data Mining"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 38: Thuật ngữ tiếng Anh nào có nghĩa là Khai phá dữ liệu?",
        options: [
            "Data Mining",
            "Data Clustering",
            "Data Classification",
            "Association Rule"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 39: Thuật ngữ tiếng Anh nào có nghĩa là Phân lớp dữ liệu?",
        options: [
            "Data Classification",
            "Data Clustering",
            "Data Mining",
            "Association Rule"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 40: Có N phần tử cần chia thành 1 cụm. Hỏi có bao nhiêu cách chia cụm?",
        options: [
            "1 cách",
            "0 cách",
            "2 cách",
            "N cách"
        ],
        correctAnswer: 0
    },
{
        question: "Câu 41: Có N phần tử cần chia thành m cụm, với m > N. Hỏi có bao nhiêu cách chia cụm?",
        options: [
            "0 cách",
            "m cách",
            "2 cách",
            "N cách"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 42: Có bao nhiêu thuật toán phân cụm?",
        options: [
            "Rất nhiều",
            "Chỉ có 3 thuật toán: Liên kết đơn, liên kết đầy đủ, k-means",
            "Chỉ có 2 thuật toán: Liên kết đơn và liên kết đầy đủ",
            "Chỉ có 2 thuật toán: Liên kết đơn và k-means"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 43: Trong thuật toán phân cụm k-means, ban đầu k tâm được chọn: ",
        options: [
            "Chọn ngẫu nhiên",
            "Chọn k phần tử nằm ở tâm",
            "Chọn k phần tử có giá trị nhỏ nhất",
            "Chọn k phần tử có giá trị bằng giá trị trung bình của các phần tử trong tập dữ liệu"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 44: Sử dụng thuật toán k-means để chia N điểm vào k cụm, khi đó:",
        options: [
            "k ≤ N",
            "k = N",
            "k > N",
            "k khác N"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 45: Cho tập dữ liệu X = {x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Khoảng cách giữa 2 phần tử x1 và x2 bằng bao nhiêu?",
        image: "images/45.jpg",
        imageCaption: "",
        options: [
            "Bằng 1",
            "Bằng 2",
            "Bằng 0",
            "Bằng 9"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 46: Cho tập dữ liệu X = {x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Khoảng cách giữa 2 phần tử x1 và x5 bằng bao nhiêu?",
        image: "images/46.jpg",
        imageCaption: "",
        options: [
            "Bằng 5",
            "Bằng 2",
            "Bằng 0",
            "Bằng 9"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 47: Cho tập dữ liệu X = {x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đơn (Single Linkage), bước đầu tiên 2 phần tử nào được chọn để gom thành một cụm?",
        image: "images/47.jpg",
        imageCaption: "",
        options: [
            "x1 và x2",
            "x1 và x3",
            "x2 và x3",
            "x3 và x5"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 48: Cho tập dữ liệu X = {x1, x2, x3, x4, x5} và ma trận không tương tự. Sử dụng thuật toán liên kết đầy đủ (Complete Linkage), bước đầu tiên 2 phần tử nào được chọn để gom thành 1 cụm?",
        image: "images/48.jpg",
        imageCaption: "",
        options: [
            "x1 và x2",
            "x1 và x3",
            "x2 và x3",
            "x3 và x5"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 49: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 2.5, hỏi có mấy cụm được sinh ra?",
        image: "images/49.jpg",
        imageCaption: "",
        options: [
            "3 cụm",
            "2 cụm",
            "1 cụm",
            "4 cụm"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 50: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 5, hỏi có mấy cụm được sinh ra?",
        image: "images/50.jpg",
        imageCaption: "",
        options: [
            "1 cụm",
            "2 cụm",
            "3 cụm",
            "4 cụm"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 51: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 3.5 hỏi có mấy cụm được sinh ra?",
        image: "images/51.jpg",
        imageCaption: "",
        options: [
            "2 cụm",
            "3 cụm",
            "1 cụm",
            "4 cụm"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 52: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 1.5 hỏi có mấy cụm được sinh ra?",
        image: "images/52.jpg",
        imageCaption: "",
        options: [
            "4 cụm",
            "2 cụm",
            "1 cụm",
            "5 cụm"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 53: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 0.5 hỏi có mấy cụm được sinh ra?",
        image: "images/53.jpg",
        imageCaption: "",
        options: [
            "5 cụm",
            "2 cụm",
            "1 cụm",
            "4 cụm"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 54: ID3 viết tắt của cụm từ nào?",
        options: [
            "Interactive Dichotomizer 3",
            "Interface Dictionary 3",
            "Items Desc 3",
            "3 Interacty Rich"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 55: Nhiệm vụ của thuật toán ID3 là?",
        options: [
            "Đưa ra cây quyết định từ một tập dữ liệu huấn luyện",
            "Không giải quyết vấn đề liên quan tới cây quyết định",
            "Tìm ra một tập trong cây",
            "Không có cây quyết định được tìm ra"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 56: Phần mềm nào sau đây sử dụng minh họa thuật toán Apriori?",
        options: [
            "Phần mềm Weka",
            "Phần mềm Project",
            "Phần mềm Prolog",
            "Phần mềm Spybot"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 57: Phần mềm Weka cài đặt một số thuật toán trong lĩnh vực nào?",
        options: [
            "Data Mining",
            "Tìm kiếm văn bản",
            "Trí tuệ nhân tạo",
            "Học máy"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 58: Đầu vào của thuật toán FP-Growth là gì?",
        options: [
            "Một CSDL giao dịch và min_sup_count",
            "Tập các mục thường xuyên",
            "Độ tin cậy",
            "Độ hỗ trợ"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 59: Đầu ra của thuật toán FP-Growth là gì?",
        options: [
            "Tập các mục thường xuyên",
            "Một CSDL giao dịch và min_sup_count",
            "Support",
            "Độ hỗ trợ"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 60: Giá trị Gain của thuộc tính A trong tập S được ký hiệu là?",
        options: [
            "Gain(S, A)",
            "Gain(A, S)",
            "Gain(entropy, S, A)",
            "Gain(S, A, entropy)"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 61: Quá trình khai phá tri thức trong CSDL (KDD) có thể phân chia thành các giai đoạn sau:",
        options: [
            "Trích chọn dữ liệu, tiền xử lý dữ liệu, biến đổi dữ liệu, khai phá dữ liệu, đánh giá và biểu diễn tri thức",
            "Tiền xử lý dữ liệu, biến đổi dữ liệu, khai phá dữ liệu, đánh giá và biểu diễn tri thức",
            "Trích chọn dữ liệu, tiền xử lý dữ liệu, biến đổi dữ liệu, khai phá dữ liệu, khai phá luật kết hợp",
            "Tiền xử lý dữ liệu, phân lớp, phân cụm, đánh giá và biểu diễn tri thức"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 62: Các loại đặc trưng của dữ liệu gồm:",
        options: [
            "Đặc trưng danh nghĩa, đặc trưng theo thứ tự, đặc trưng đo theo khoảng, đặc trưng đo theo tỷ lệ",
            "Đặc trưng danh nghĩa, đặc trưng theo thứ tự, đặc trưng đo theo khoảng, đặc trưng theo khối lượng",
            "Đặc trưng danh nghĩa, đặc trưng theo thứ tự, đặc trưng đo theo khoảng, đặc trưng theo chiều dài",
            "Đặc trưng theo thứ tự, đặc trưng đo theo khoảng, đặc trưng đo theo tỷ lệ"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 63: Một số bài toán điển hình trong khai phá dữ liệu là:",
        options: [
            "Khai phá luật kết hợp, phân loại, phân cụm, hồi quy...",
            "Khai phá luật kết hợp, xây dựng máy tìm kiếm...",
            "Web mining, Text mining, mạng nơron…",
            "Bài toán nhận dạng, tìm kiếm thông tin, lựa chọn đặc trưng..."
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 64: Một số thách thức lớn trong quá trình khai phá dữ liệu là(chọn đáp án đúng nhất):",
        options: [
            "Dữ liệu quá lớn, dữ liệu bị thiếu hoặc nhiễu, dữ liệu phức tạp, thường xuyên thay đổi",
            "Trình độ con người hạn chế, dữ liệu không lưu trữ tập trung",
            "Dữ liệu lớn, máy khai phá dữ liệu tốc độ hạn chế",
            "Tốc độ xử lý máy tính hạn chế, dữ liệu thường xuyên thay đổi"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 65: Một số lĩnh vực liên quan đến khai phá tri thức -KDD là:",
        options: [
            "Machine Learning, Visualization, Statistics, Databases",
            "Machine Learning, Programming, Statistics, Databases",
            "Machine Learning, Visualization, Statistics, Bioinformatics",
            "Support Vector Machine, Clustering, Statistics, Databases"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 66: Khai phá dữ liệu mang lại lợi ích gì?",
        options: [
            "Cung cấp hỗ trợ ra quyết định, dự báo, khái quát dữ liệu...",
            "Tìm kiếm các quy luật, tìm kiếm cụm và phân loại dữ liệu",
            "Tìm kiếm nhanh thông tin, thống kê dữ liệu, chọn đặc trưng của dữ liệu...",
            "Tạo ra cơ sở tri thức mới,hỗ trợ dự báo thời tiết, dự báo động đất, dự báo sóng thần... "
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 67: Làm sạch dữ liệu (Data Cleaning) là quá trình:",
        options: [
            "Loại bỏ nhiễu và dữ liệu không nhất quán",
            "Tìm kiếm dữ liệu có ích",
            "Tìm kiếm dữ liệu có ích trong CSDL lớn",
            "Tổ hợp nhiều nguồn dữ liệu khác nhau"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 68: Một số ứng dụng tiềm năng của Khai phá dữ liệu là:",
        options: [
            "Phân tích và quản lý thị trường, Quản lý và phân tích rủi ro, Quản lý và phân tích các sai hỏng, Khai thác Web, Khai thác văn bản (text mining)… ",
            "Tìm kiếm văn bản, Tìm kiếm hình ảnh, Tìm kiếm tri thức mới trên Internet... ",
            "Phân tích tâm lí khách hàng, Hỗ trợ kinh doanh, tối ưu hóa phần cứng máy tính... ",
            "Phân tích thị trường chứng khoán, bất động sản, tìm kiếm dữ liệu bằng các máy tìm kiếm... "
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 69: Các cơ sở dữ liệu cần khai phá là:",
        
        options: [
            "Quan hệ, giao tác, hướng đối tượng, không gian, thời gian, text, XML, multimedia, WWW...",
            "Text, XML, multimedia, WWW...",
            "Cơ sở dữ liệu khách hàng, cơ sở dữ liệu nghiên cứu không gian, cơ sở dữ liệu trong ngân hàng, cơ sở dữ liệu thống kê… ",
            "Cơ sở dữ liệu tuyển sinh đại học, cơ sở dữ liệu dự báo thời tiết, cơ sở dữ liệu thống kê dân số… "
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 70: Thuật ngữ Big Data có nghĩa là:",
        options: [
            "Các tập dữ liệu rất lớn và phức tạp đến mức các kỹ thuật IT truyền thống không xử lý nổi",
            "Dữ liệu rất lớn",
            "Dữ liệu tích hợp từ nhiều nguồn khác nhau",
            "Dữ liệu khổng lồ trên Internet"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 71: Thuật ngữ BioInfomatics có nghĩa là:",
        options: [
            "Giải quyết các bài toán sinh học bằng việc sử dụng các phương pháp của khoa học tính toán",
            "Sinh học phân tử",
            "Tìm kiếm dữ liệu mới từ sinh học",
            "Khai thác các thông tin có ích trong lĩnh vực y học"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 72: Phát biểu nào sau đây là đúng?",
        options: [
            "Data Mining là một bước quan trọng trong quá trình khai phá tri thức từ dữ liệu -KDD",
            "Tiền xử lí dữ liệu là chọn ra các đặc trưng tiêu biểu trong tập dữ liệu lớn",
            "Mọi dữ liệu đều có thể tìm kiếm được bằng máy tìm kiếm của Google",
            "Data Mining là công cụ giúp lập trình viên dễ dàng tìm kiếm thông tin hơn"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 73: Làm sạch dữ liệu là:",
        options: [
            "Điền giá trị thiếu, làm trơn dữ liệu nhiễu, định danh hoặc xóa ngoại lai và khử tính không nhất quán",
            "Chuẩn hóa và tổng hợp",
            "Bước cuối cùng trong quá trình Data Mining",
            "Tích hợp CSDL, khối dữ liệu hoặc tập tin phức"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 74: Các bài toán thuộc làm sạch dữ liệu là:",
        
        options: [
            "Xử lý giá trị thiếu, Dữ liệu nhiễu: định danh ngoại lai và làm trơn, Chỉnh sửa dữ liệu không nhất quán, Giải quyết tính dư thừa tạo ra sau tích hợp dữ liệu",
            "Làm trơn theo biên, phương pháp đóng thùng, điền giá trị thiếu, Giải quyết tính dư thừa tạo ra sau tích hợp dữ liệu. ",
            "Phân cụm, phân lớp, hồi quy, biểu diễn dữ liệu",
            "Phân cụm, tìm luật kết hợp, tìm kiếm đặc trưng"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 75: Cho một tập dữ liệu có n đặc trưng. Có bao nhiêu tập con không rỗng chứa các đặc trưng được lựa chọn?",
        options: [
            "2^n - 1",
            "2^n",
            "Vô số tập con",
            "n^2"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 76: Một số phương pháp loại bỏ dữ liệu nhiễu là:",
        
        options: [
            "Bỏ qua bản ghi có dữ liệu thiếu, điền giá trị thiếu bằng tay, điền giá trị tự động",
            "Loại bỏ dựa trên quan sát, loại bỏ khi lựa chọn đặc trưng",
            "Loại bỏ toàn bộ dữ liệu bị nhiễu và thay thế bằng tập dữ liệu mới, lựa chọn các đặc trưng quan trọng ",
            "Sử dụng các thuật toán phân lớp, phân cụm, luật kết hợp"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 77: Cho bản ghi dữ liệu, giá trị của các thuộc tính như sau: X=(6, 2, 5, 7, 5, ?). Dấu hỏi là giá trị của thuộc tính bị thiếu. Sử dụng phương pháp tính trung bình giá trị của các thuộc tính của bản ghi hiện có, hãy cho biết vị trí dấu hỏi điền giá trị là bao nhiêu: ",
        
        options: [
            "5",
            "6",
            "9",
            "Giá trị khác"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 78: Khi xử lý thiếu giá trị của các bản ghi dữ liệu, phương pháp ‘Bỏ qua bản ghi có giá trị thiếu’ chỉ thích hợp khi: ",
        options: [
            "Các bản ghi bị thiếu chiếm tỷ lệ nhỏ trong toàn bộ dữ liệu",
            "Các bản ghi có dữ liệu bị thiếu chiếm tỷ lệ lớn trong toàn bộ dữ liệu ",
            "Có thể bỏ qua tất cả bản ghi bị thiếu",
            "Không thể bỏ qua, phải tìm các giá trị để điền vào các bản ghi bị thiếu "
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 79: Cho cơ sở dữ liệu giao dịch gồm N giao dịch (bản ghi). I là tập chứa tất cả các mục (item) trong CSDL. X là một tập chứa các mục thuộc I. Giao dịch hỗ trợ X là giao dịch chứa tất cả các mục có trong X. Độ hỗ trợ của tập mục X được định nghĩa là: ",
        
        options: [
            "Support(X) = Số lượng giao dịch hỗ trợ X / N",
            "Support(X) = Số lượng giao dịch hỗ trợ X",
            "Support(X) = Số lượng giao dịch hỗ trợ X / N * |I||, trong đó |I| là tổng số mục trong CSDL ",
            "Support(X) = Số lượng giao dịch hỗ trợ X * 100%"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 80: Cho cơ sở dữ liệu giao dịch gồm N giao dịch (bản ghi). I là tập chứa tất cả các mục (item) trong CSDL. X, Y là tập chứa các mục thuộc I. Độ tin cậy của luật kết hợp X Y được định nghĩa là: ",
        options: [
            "Confidence(X→Y) = Số giao dịch chứa X và Y / Số giao dịch chứa X",
            "Confidence(X→Y) = Số giao dịch chứa X / Số giao dịch chứa Y",
            "Confidence(X→Y) = Số giao dịch chứa X và Y / Số giao dịch chứa Y",
            "Confidence(X→Y) = Số giao dịch chứa X và Y / N"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 81: Cho cơ sở dữ liệu giao dịch gồm N giao dịch (bản ghi). I là tập chứa tất cả các mục (item) trong CSDL. X, Y là tập chứa các mục thuộc I. Độ hỗ trợ của luật kết hợp X Y được định nghĩa là: ",
        
        options: [
            "Support(X→Y) = Số giao dịch chứa X và Y / N",
            "Support(X→Y) = Số giao dịch chứa X và Y / Số giao dịch chứa Y",
            "Support(X→Y) = Số giao dịch chứa X và Y / Số giao dịch chứa X",
            "Support(X→Y) = Số giao dịch chứa X / Số giao dịch chứa Y"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 82: Cho cơ sở dữ liệu giao dịch gồm N giao dịch (bản ghi). I là tập chứa tất cả các mục (item) trong CSDL. Min_Supp là độ hỗ trợ tối thiểu. X là tập chứa các mục thuộc I. Tập mục X được gọi là tập mục thường xuyên (frequent itemset) nếu: ",
        options: [
            "Support(X) ≥ Min_Support",
            "Support(X) ≤ Min_Support",
            "Support(X) = Min_Support",
            "Support(X) : Min_Support / N"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 83: Cho cơ sở dữ liệu giao dịch gồm N giao dịch (bản ghi). I là tập chứa tất cả các mục (item) trong CSDL. Min_Supp là độ hỗ trợ tối thiểu, Min_Conf là độ tin cậy tối thiểu. X, Y là tập chứa các mục thuộc I. Luật kết hợp XY được chọn nếu: ",
        options: [
            "Support(X→Y) ≥ Min_Support và Confidence(X→Y) ≥ Min_Confidence",
            "Support(X→Y) = Min_Support và Confidence(X→Y) = Min_Confidence",
            "Support(X→Y) < Min_Support và Confidence(X→Y) < Min_Confidence",
            "Support(X→Y) > Min_Support và Confidence(X→Y) = Min_Confidence"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 84: Cho CSDL giao dịch như hình vẽ. Độ hỗ trợ tối thiểu Min_Support = 3 (60%) và độ tin cậy tối thiểu Min_Confidence = 100%. Các tập mục thường xuyên có 1 mục thỏa mãn Min_Supp là: ",
        image: "images/84.jpg",
        imageCaption: "",
        options: [
            "F:4, C:4, A:3, C:3, M:3, P:3",
            "C:4, A:3, C:3, M:3, P:3",
            "F:4, C:4",
            "A:3, C:3, M:3, P:3"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 85: Cho CDSL giao dịch như hình vẽ, Độ hỗ trợ tối thiểu Min_Support = 3 (60%) và độ tin cậy tối thiểu Min_Confidence = 100%. Tập mục thường xuyên có 4 mục thỏa mãn Min_Supp là:  ",
        image: "images/85.jpg",
        imageCaption: "",
        options: [
            "FCAM:3",
            "FCAM:2",
            "FC:4",
            "FCAM:4"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 86: Cho CSDL giao dịch như hình vẽ. Độ hỗ trợ tối thiểu Min_Support = 3 (60%) và độ tin cậy tối thiểu Min_Confidence = 100%.Cơ sở điều kiện của nút M là:   ",
        image: "images/86.jpg",
        imageCaption: "",
        options: [
            "{F:2, C:2, A:2} và {F:1, C:1, A:1, B:1}",
            "{F:2, C:2, A:2}",
            "F:1, C:1, A:1",
            "F:3, C:3, A:3"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 87: Cho CSDL giao dịch như hình vẽ. Độ hỗ trợ tối thiểu Min_Support = 3 (60%) và độ tin cậy tối thiểu Min_Confidence = 100%. Cơ sở điều kiện của nút M là:  ",
        image: "images/87.jpg",
        imageCaption: "",
        options: [
            "{F:2, C:2, A:2, M:2} và {C:1, B:1}",
            "{F:2, C:2, A:2, M:2}",
            "C:3",
            "F:3, C:3, A:3"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 88: Cho CDSL giao dịch như hình vẽ. Độ hỗ trợ tối thiểu Min_Support = 3 (60%) và độ tin cậy tối thiểu Min_Confidence = 100%. Cây điều kiện FP của P là:  ",
        image: "images/88.jpg",
        imageCaption: "",
        options: [
            "{C:3} | p",
            "{CF:3} | p",
            "{C:4} | p",
            "Cây điều kiện rỗng"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 89: Cho CSDL giao dịch như hình vẽ. Độ hỗ trợ tối thiểu Min_Support = 3 (60%) và độ tin cậy tối thiểu Min_Confidence = 100%.Cây điều kiện FP của A là:   ",
        image: "images/89.jpg",
        imageCaption: "",
        options: [
            "{F:3, C:3} | p",
            "{CF:3} | p",
            "{C:4} | p",
            "Cây điều kiện rỗng"
        ],
        correctAnswer: 0
    },
    {
        question: "Câu 90: Cho CSDL giao dịch gồm N mục phân biệt, tổng số tập mục sinh ra (không tính tập rỗng) là:",
        options: [
            "2^N - 1",
            "2^N",
            "N",
            "Vô số tập mục"
        ],
        correctAnswer: 0
    },
  {
    question: "Câu 91: Cho A, B, C, D là các item và A-->BC là luật kết hợp thỏa mãn độ hỗ trợ tối thiểu Min_Sup và độ tin cậy tối thiểu Min_Conf. Hãy cho biết luật kết hợp nào sau đây chắc chắn thỏa mãn Min_Sup và Min_Conf mà không cần phải tính độ hỗ trợ và độ tin cậy: ",
    options: [
      "AB-->C",
      "A-->D",
      "ABD-->C",
      "D-->C"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 92: Cho A, B, C, là các item và A-->BC là luật kết hợp thỏa mãn độ hỗ trợ tối thiểu Min_Sup và độ tin cậy tối thiểu Min_Conf. Ta thấy rằng luật kết hợp AB-->C cũng thỏa mãn điều kiện về độ hỗ trợ tối thiểu và độ tin cậy tối thiểu vì: ",
    options: [
      "Confidence(AB-->C) >= Confidence(A-->BC)",
      "Confidence(AB-->C) <= Confidence(A-->BC)",
      "Confidence(AB-->C) : Confidence(A-->BC)",
      "Chưa kết luận được AB-->C có thỏa độ hỗ trợ tối tiểu và độ tin cậy tối thiểu hay không "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 93: Cho A, B, C, D là các mục trong cơ sở dữ liệu giao dịch. Kết luận nào sau đây là sai: ",
    options: [
      "Support(ABC) < Support(ABCD)",
      "Support(ABC) >= Support(ABCD)",
      "Support(AB) >= Support(ABC)",
      "Support(AB) <= Support(A)"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 94: Phát biểu nào sau đây là đúng?",
    options: [
      "Confidence(AC-->B) >= Confidence(A-->BC)",
      "Confidence(AC-->B) <= Confidence(A-->BC)",
      "Confidence(A-->AB) >= Confidence(AC-->C)",
      "Confidence(AB-->C) >= Confidence(AC-->B)"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 95: Giả sử ta có các tập mục thường xuyên {A,B}, {A,C}, {B,D} chứa 2-item. Sử dụng thuật toán Apriori để ghép các tập mục có 2-item thành các tập mục có 3-item , các ứng viên sinh ra có 3-item là: ",
    options: [
      "{A, B, C}, {A, B, D}",
      "{A, B, C}, {A, B, D}, {A, B, C, D}",
      "{A, B, C}, {B, C, D}",
      "{A, B, C}, {C, B, D}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 96: Trong thuật toán Apriori, tập mục chứa k-item được tạo ra bằng cách nào trong các cách sau: ",
    options: [
      "Tạo ra từ tập chứa k-1 item bằng cách ghép 2 tập k-1 item với nhau với điều kiện là 2 tập k-1 item này phải có chung nhau k-2 item ",
      "b.	Tổ hợp k item từ các item có trong cơ sở dữ liệu giao dịch. ",
      "Lấy ngẫu nhiên k item sau đó ghép lại với nhau",
      "Sinh mọi tập con có k item từ các item có trong cơ sở dữ liệu giao dịch "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 97: Cho tập L3={abc, abd, ade, ace} là các tập mục thường xuyên chứa 3-item.Để tạo các ứng viên chứa 4-item abcd, ta cần ghép các tập chứa 3-item nào với nhau? ",
    options: [
      "abc và abd",
      "abc và ade",
      "abc và ace",
      "abd và ade"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 98: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%), Min_Cofidence = 50%. Luật kết hợp nào không thỏa mãn điều kiện đề bài:  ",
    image: "images/98.jpg",
        imageCaption: "",
    options: [
      "BA-->E",
      "BC-->E",
      "C-->E",
      "B-->C"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 99: ho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%), Min_Cofidence = 50%. Luật kết hợp nào có độ tin cậy = 100%  ",
    
    image: "images/99.jpg",
    imageCaption: "",
    options: [
      "B-->E",
      "A-->D",
      "C-->E",
      "AB-->C"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 100: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%), Min_Cofidence = 50%. Luật kết hợp nào có độ tin cậy = 75%  ",
    image: "images/100.jpg",
    imageCaption: "",
    options: [
      "B-->CE",
      "A-->D",
      "C-->E",
      "AB-->C"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 101: Cho CSDL giao dịch với Min_Support = 2 (50%). Tập nào là tập mục thường xuyên với độ hỗ trợ 50%?",
    image: "images/101.jpg",
    imageCaption: "",
    options: [
      "{A, C}",
      "{A, E}",
      "{A, C, D}",
      "{B, C, D}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 102: Cho CSDL giao dịch với Min_Support = 2 (50%). Tập nào là tập mục thường xuyên có độ hỗ trợ cao nhất?",
    image: "images/102.jpg",
    imageCaption: "",
    options: [
      "{B, E}",
      "{A, E}",
      "{A, C, D}",
      "{B, C, D}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 103: Cho CSDL giao dịch với Min_Support = 2 (50%). Tập nào có độ hỗ trợ 100%?",
    image: "images/103.jpg",
    imageCaption: "",
    options: [
      "Không có tập nào",
      "{A, E}",
      "{A, C, D}",
      "{B, E}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 104: Cho CSDL giao dịch với Min_Support = 2 (50%). Tập nào có độ hỗ trợ 25%?",
    image: "images/104.jpg",
    imageCaption: "",
    options: [
      "{A, C, D}",
      "{A, C}",
      "{E, B}",
      "{B, C}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 105: Cho CSDL giao dịch với Min_Support = 2 (50%), Min_Confidence = 50%. Luật nào có độ tin cậy 100%?",
    image: "images/105.jpg",
    imageCaption: "",
    options: [
      "{BC-->E, B-->E}",
      "A-->D",
      "AC-->E",
      "B-->C"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 106: Cho CSDL giao dịch với Min_Support = 2 (50%). Sử dụng thuật toán Apriori, sau lần duyệt thứ nhất, các danh sách L1 chứa các tập mục thường xuyên có 1-item được tạo ra là ",
    image: "images/106.jpg",
    imageCaption: "",
    options: [
      "L1={{A}, {B}, {C}, {E}}",
      "L1={{A}, {B}, {C}, {D}}",
      "L1={{A}, {B}, {D}, {E}}",
      "L1={{A}, {D}, {C}}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 107: Cho CSDL giao dịch với Min_Support = 2 (50%). Tập nào là tập mục thường xuyên với độ hỗ trợ là = 70% ",
    image: "images/107.jpg",
    imageCaption: "",
    options: [
      "Không có tập nào",
      "{A, E}",
      "{A, C, D}",
      "{B, C, D}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 108: Cho CSDL giao dịch với Min_Support = 2 (50%). Sử dụng thuật toán Apriori để tìm các tập mục thường xuyên, số lần duyệt CSDL là: ",
    image: "images/108.jpg",
    imageCaption: "",
    options: [
      "3 lần",
      "2 lần",
      "4 lần",
      "1 lần"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 109: Trong FP-Tree, mũi tên nét đứt biểu thị cho:",
    image: "images/109.jpg",
    imageCaption: "",
    options: [
      "Con trỏ xuất phát từ bảng đầu mục, trỏ vào nút sinh ra đầu tiên có cùng tên. Nút sinh ra sau có con trỏ từ nút cùng tên sinh ra ngay trước đó trỏ vào",
      "Đường đi trên cây",
      "Nút sinh sau trỏ vào nút sinh trước",
      "Hướng duyệt cây"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 110: Cho FP-Tree, cơ sở điều kiện của nút P là:",
    image: "images/110.jpg",
    imageCaption: "",
    options: [
      "{f:2, c:2, a:2, m:2} và {c:1, b:1}",
      "{f:3, c:3, a:3, m:2}",
      "{f:4, c:3, a:3, m:2}",
      "{f:2, c:2, a:2, m:2, p:2} và {c:1, b:1, p:1}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 111: Cho FP-Tree, cơ sở điều kiện của nút M là:",
    image: "images/111.jpg",
    imageCaption: "",
    options: [
      "{f:2, c:2, a:2}, {f:1, c:1, a:1, b:1}",
      "{f:4, c:4, a:3}, {f:4, c:3, a:3, b:1}",
      "{f:2, c:2, a:2, m:2}, {f:1, c:1, a:1, b:1, m:1}",
      "{f:2, c:2, a:2, m:2, p:2}, {c:1, b:1, p:1}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 112: Cho FP-Tree, cơ sở điều kiện của nút a là:",
    image: "images/112.jpg",
    imageCaption: "",
    options: [
      "{f:3, c:3}",
      "{f:4, c:3}",
      "{f:4, c:3, a:3}",
      "{f:3, c:3, a:3}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 113: Khẳng định nào sau đây là sai?",
    
    options: [
      "FP-Tree là cây nhị phân",
      "FP-Tree là cây tổng quát",
      "Khi thêm 1 giao dịch vào FP-Tree đều phải thêm bắt đầu từ gốc. ",
      "Bảng đầu mục – Header Table dùng để lưu 3 thông tin: Tên item, Số lượng item đó xuất hiện trong CSDL giao dịch và Con trỏ dùng để trỏ đến nút cùng tên được sinh ra đầu tiên "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 114: Cho cây quyết định như hình vẽ. Hãy cho biết Refund=’No’, MarSt = ‘Married’, TaxInc=’80K’ thì kết luận có giá trị gì? ",
    image: "images/114.jpg",
    imageCaption: "",
    options: [
      "No",
      "Yes",
      "Không phân lớp được",
      "Thiếu thông tin"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 115: Cho cây quyết định như hình vẽ. Hãy cho biết Refund=’Yes’, MarSt = ‘Married’, TaxInc=’40K’ thì kết luận có giá trị gì? ",
    image: "images/115.jpg",
    imageCaption: "",
    options: [
      "No",
      "Yes",
      "Không phân lớp được",
      "Thiếu thông tin để kết luật"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 116: Cho cây quyết định như hình vẽ. Hãy cho biết Refund=’No’, MarSt = ‘Single’, TaxInc=’140K’ thì kết luận có giá trị gì? ",
    image: "images/116.jpg",
    imageCaption: "",
    options: [
      "Yes",
      "No",
      "Không phân lớp được",
      "Thiếu thông tin để kết luận"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 117: Cho cây quyết định như hình vẽ. Hãy cho biết Refund=’No’, MarSt = ‘Single’, TaxInc=’80K’ thì kết luận có giá trị gì? ",
    image: "images/117.jpg",
    imageCaption: "",
    options: [
      "Yes",
      "No",
      "Không phân lớp được",
      "Married"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 118: Cho cây quyết định như hình vẽ. Có bao nhiêu luật sinh ra từ cây quyết định trên: ",
    image: "images/118.jpg",
    imageCaption: "",
    options: [
      "4 luật",
      "2 luật",
      "1 luật",
      "Nhiều luật"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 119: Có thể sử dụng phân lớp dựa trên mạng Nơron nhân tạo. Vậy mạng Nơron nhân tạo là gì? ",
    options: [
      "Là mô hình toán học mô phỏng theo mạng Nơron sinh học để giải quyết các bài toán ",
      "Là mạng máy tính có tốc độ truyền thông cao ",
      "Là mạng Nơron do con người tạo ra ",
      "Là một phương pháp để phân loại Gen của các loài sinh vật "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 120: Cho tập ví dụ học như bảng. Entropy của kết luận C= Play Ball là: ",
    image: "images/120.jpg",
    imageCaption: "",
    options: [
      "Entropy(C) = 1",
      "Entropy(C) = 3",
      "Entropy(C) = 0.5",
      "Entropy(C) = 6"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 121: Cho tập ví dụ học như bảng. Entropy của thuộc tính Outlook = ‘Sunny’ là: ",
    image: "images/121.jpg",
    imageCaption: "",
    options: [
      "Giá trị khác",
      "Entropy(Outlook='Sunny') = 1",
      "Entropy(Outlook='Sunny') = 0.5",
      "Entropy(Outlook='Sunny') = 0"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 122: Cho tập ví dụ học như bảng. Entropy của thuộc tính Outlook là: ",
    image: "images/122.jpg",
    imageCaption: "",
    options: [
      "Giá trị khác",
      "Entropy(Outlook) = 1",
      "Entropy(Outlook) = 0.5",
      "Entropy(Outlook) = 0"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 123: Cho tập ví dụ học như bảng. P(Play Ball= ‘Yes’ | Outlook=’Overcast’) là: ",
   image: "images/123.jpg",
    imageCaption: "",
    options: [
      "2/3",
      "1/3",
      "0/3",
      "Giá trị khác"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 124: Cho tập ví dụ học như bảng. P(Play Ball= ‘No’ | Outlook=’Overcast’) là: ",
    image: "images/124.jpg",
    imageCaption: "",
    options: [
      "0/3",
      "1/3",
      "2/3",
      "Giá trị khác"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 125: Cho tập ví dụ học như bảng. P(Play Ball= ‘No’ | Wind =’Weak’) là: ",
    image: "images/125.jpg",
    imageCaption: "",
    options: [
      "2/3",
      "1/3",
      "0/3",
      "Giá trị khác"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 126: Cho tập ví dụ học như bảng. P(Play Ball= ‘No’) là: ",
    image: "images/126.jpg",
    imageCaption: "",
    options: [
      "1/2",
      "1/3",
      "0/3",
      "Giá trị khác"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 127: Cho tập ví dụ học như bảng. P(Wind= ‘Weak’) là: ",
    image: "images/127.jpg",
    imageCaption: "",
    options: [
      "4/6",
      "3/6",
      "2/6",
      "Giá trị khác"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 128:  Độ phân biệt (độ lộn xộn) của kết luận C với thuộc tính A được tính theo công thức: ",
    options: [
      "Gain(C, A) = Entropy(C) - Entropy(A)",
      "Gain(C, A) = Entropy(C) + Entropy(A)",
      "Gain(C, A) = Entropy(A) - Entropy(C)",
      "Gain(C, A) = Entropy(C) * Entropy(A)"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 129: Kết luận nào sau đây là sai?",
    options: [
      "Thuật toán Quilan chọn ngẫu nhiên 1 thuộc tính để làm gốc cây quyết định ",
      "Độ phân biệt (độ lộn xộn) của một thuộc tính với kết luận C cao nhất thì Entropy của nó thấp nhất ",
      "Thuật toán học khái niệm CLS chọn ngẫu nhiên 1 thuộc tính để làm gốc cây quyết định ",
      "Entropy là một số biến thiên trong đoạn [0,1].  "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 130: Kết luận C gồm 2 giá trị Yes và No. Entropy(C: 1 nói nên điều gì: ",
    options: [
      "Số kết luận Yes = số kết luận No",
      "Số kết luận Yes = 0",
      "Số kết luận No = 0",
      "Không kết luận được"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 131: Kết luận C gồm 2 giá trị Yes và No. Entropy(C: 0 nói nên điều gì: ",
    options: [
      "Số kết luận Yes = 0 hoặc Số kết luận No = 0",
      "Số kết luận Yes = Số kết luận No",
      "Số kết luận Yes = 1 và Số kết luận No = 1",
      "Không kết luận được điều gì"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 132: Khi sử dụng thuật toán Quilan để xây dựng cây quyết định. Tại mỗi bước của thuật toán ta chọn thuộc tính nào trong số các thuộc tính còn lại để làm gốc phân nhánh? ",
    options: [
      "Thuộc tính có độ phân biệt cao nhất",
      "Thuộc tính có độ phân biệt thấp nhất",
      "Thuộc tính có Entropy cao nhất",
      "Chọn ngẫu nhiên"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 133: Khi sử dụng thuật toán CLS (Concept Learning System) để xây dựng cây quyết định. Tại mỗi bước của thuật toán ta chọn thuộc tính nào trong số các thuộc tính còn lại để làm gốc phân nhánh? ",
    options: [
      "Chọn ngẫu nhiên",
      "Thuộc tính có độ phân biệt thấp nhất",
      "Thuộc tính có Entropy cao nhất",
      "Thuộc tính có độ phân biệt cao nhất"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 134: Entropy là một đại lượng có miền giá trị là: ",
    options: [
      "[0 ; 1]",
      "(0 ; 1)",
      "Miền giá trị là tập số nguyên dương ",
      "Miền giá trị là tập số thực dương "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 135: Thuật toán Quilan dùng để:",
    options: [
      "Xây dựng cây quyết định",
      "Tìm các luật",
      "Tìm độ phân biệt của các thuộc tính",
      "Giúp ta tìm ra 1 thuộc tính làm gốc cây quyết định "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 136: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Có bao nhiêu tổ hợp gồm có 1 thuộc tính: ",
    image: "images/136.jpg",
    imageCaption: "",

    options: [
      "4 tổ hợp",
      "5 tổ hợp",
      "6 tổ hợp",
      "2 tổ hợp"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 137: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Có bao nhiêu tổ hợp gồm có 2 thuộc tính phân biệt: ",
    image: "images/137.jpg",
    imageCaption: "",

    options: [
      "6 tổ hợp",
      "5 tổ hợp",
      "4 tổ hợp",
      "2 tổ hợp"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 138: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Có bao nhiêu tổ hợp gồm có 3 thuộc tính phân biệt: ",
    image: "images/138.jpg",
    imageCaption: "",

    options: [
      "4 tổ hợp",
      "1 tổ hợp",
      "6 tổ hợp",
      "2 tổ hợp"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 139: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Có bao nhiêu tổ hợp gồm có 4 thuộc tính phân biệt: ",
    image: "images/139.jpg",
    imageCaption: "",

    options: [
      "1 tổ hợp",
      "4 tổ hợp",
      "6 tổ hợp",
      "2 tổ hợp"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 140: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Với bảng Play Ball=’No’, xét tổ hợp 1 thuộc tính. Tổ hợp thuộc tính nào là tổ hợp lớn nhất: ",
    image: "images/140.jpg",
    imageCaption: "",

    options: [
      "Humidity='High'",
      "Wind='Weak'",
      "Outlook='Sunny'",
      "Humidity='Normal'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 141: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Với bảng Play Ball=’No’ ta tìm được bao nhiêu luật: ",
    image: "images/141.jpg",
    imageCaption: "",

    options: [
      "2 luật",
      "3 luật",
      "1 luật",
      "4 luật"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 142: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Với bảng Play Ball=’No’ ta tìm được các luật sau: ",
    image: "images/142.jpg",
    imageCaption: "",
    options: [
      "If Humidity='High' Then Play Ball='No' và If Outlook='Rain' Then Play Ball='No'",
      "If Humidity='High' Then Play Ball='No'",
      "If Humidity='Normal' Then Play Ball='No' và If Outlook='Rain' Then Play Ball='No'",
      "If Outlook='Sunny' Then Play Ball='No' và If Wind='Strong' Then Play Ball='No'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 143: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Với bảng Play Ball=’Yes’ ta tìm được các luật sau: ",
    image: "images/143.jpg",
    imageCaption: "",
    options: [
      "If Outlook='Overcast' Then Play Ball='No' và If Outlook='Sunny' and Temperature='Cold' Then Play Ball='Yes'",
      "If Humidity='Normal' Then Play Ball='Yes'",
      "If Humidity=’Weak’ Then Play Ball = ‘Yes’và If Outlook = ‘Overcast’ Then Play Ball = ‘Yes’ ",
      "If Outlook='Sunny' Then Play Ball='Yes' và If Wind='Strong' Then Play Ball='Yes'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 144: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Với bảng Play Ball=’Yes’ ta tìm được mấy luật: ",
    image: "images/144.jpg",
    imageCaption: "",
    options: [
      "2 luật",
      "3 luật",
      "1 luật",
      "0 luật"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 145: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Tập ví dụ học trên sinh ra ít nhất mấy luật ",
    
    image: "images/145.jpg",
    imageCaption: "",
    options: [
      "4 luật",
      "3 luật",
      "2 luật",
      "6 luật"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 146: Cho tập ví dụ học như bảng. Sử dụng thuật toán ILA. Với bảng Play Ball=’Yes’, xét tổ hợp 1 thuộc tính. Tổ hợp thuộc tính nào là tổ hợp lớn nhất: ",
   image: "images/146.jpg",
    imageCaption: "",
    options: [
      "Outlook='Overcast'",
      "Wind='Weak'",
      "Outlook='Sunny'",
      "Humidity='Normal'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 147: Độ đo 'gần gũi' là gì?",
    options: [
      "Độ đo mức độ tương tự hoặc không tương tự giữa hai vector đặc trưng",
      "Độ đo giữa hai phần tử bất kỳ",
      "Khoảng cách giữa hai phần tử trong không gian",
      "Độ đo sử dụng trong Data Mining để phân cụm dữ liệu "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 148: Độ đo 'gần gũi' gồm:",
    options: [
      "Độ đo tương tự và độ đo không tương tự",
      "Độ đo khoảng cách và độ đo tình cảm",
      "Độ đo Ơclit và phi Ơclit",
      "Độ đo tương tự và độ đo khoảng cách trong không gian 2 chiều "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 149: Độ đo khoảng cách Ơclit là:",
    options: [
      "Độ đo không tương tự",
      "Độ đo tương tự",
      "Độ đo giữa hai đối tượng cùng loại",
      "Độ đo giữa hai đối tượng khác loại"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 150: Cho 2 điểm trong mặt phẳng toạ độ Oxy, cho 2 điểm A(x1, y1), B(x2, y2). Khoảng cách Ơclit giữa 2 điểm này là: ",
    options: [
      "d = sqr(sqrt(x1-x2)+sqrt(y1-y2)) trong đó sqr là hàm bình phương, sqrt là hàm lấy căn. ",
      "d = sqr(sqrt(x1+x2)+sqrt(y1+y2)) trong đó sqr là hàm bình phương, sqrt là hàm lấy căn. ",
      "d = x1*x2 + y1*y2",
      "Công thức khác"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 151: Cho hai điểm A(0,1), B(4,4). Khoảng cách Ơclit giữa hai điểm là:",
    options: [
      "d(A,B)=5",
      "d(A,B)=3",
      "d(A,B)=4",
      "d(A,B)=1"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 152: Cho tập C={x1, x2,. ..xk} gồm k phần tử, mỗi phần tử là một vector trong không gian N chiều. Vector trung bình mC của tập C là một vector trong không gian N chiều được định nghĩa là: ",
    options: [
      "mC = (x1 + x2 + ... + xk) / k",
      "mC = (x1 + x2 + ... + xk)",
      "mC = (x1 + x2 + ... + xk) / N",
      "mC = (x1 + x2 + ... + xk) / (k*N)"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 153: Trong thuật toán phân cụm k-mean, sau khi chọn được k điểm làm tâm, phần tử x sẽ được gán vào cụm C sao cho: ",
    options: [
      "Khoảng cách từ x đến tâm cụm C là nhỏ nhất",
      "Khoảng cách từ x đến tâm cụm C là lớn nhất",
      "Khoảng cách từ x đến tâm cụm C bằng 0",
      "Khoảng cách từ x đến tâm cụm C bằng k"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 154: Trong thuật toán k-mean, sau khi gán đối tượng vào các cụm cần:",
    options: [
      "Tính lại tâm của các cụm",
      "Tính khoảng cách giữa các phần tử trong cụm",
      "Chọn phần tử đại diện của cụm",
      "Trộn các cụm lại với nhau để số cụm sinh ra là ít nhất "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 155: Cho các điểm A(1, 1), B(2, 1), C(4, 3), D(5, 4). Sử dụng thuật toán phân cụm k-mean để chia 4 điểm vào 2 cụm. Kết quả phân cụm là: ",
    options: [
      "C1={A,B}; C2={C,D}",
      "C1={A,C}; C2={B,D}",
      "C1={A,B,C}; C2={D}",
      "C1={A,B,D}; C2={C}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 156: Cho các điểm A(1, 1), B(2, 1), C(4, 3), D(5, 4), E( 1, 0). Sử dụng thuật toán phân cụm k-mean để chia 5 điểm vào 2 cụm. Kết quả phân cụm là: ",
    options: [
      "C1={A,B,E}; C2={C,D}",
      "C1={A,C,E}; C2={B,D}",
      "C1={A,B,C}; C2={D,E}",
      "C1={A,B,D}; C2={C,E}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 157: Cho cụm C gồm các điểm A(1, 1), B(2, 1), C(3,1). Giả sử đại diện của cụm là một điểm (vector trung bình). Vetor trung bình của cụm là: ",
    options: [
      "mC = (2 ; 1)",
      "mC = (2 ; 0)",
      "mC = (2.5 ; 1.5)",
      "mC = (0 ; 0)"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 158: Cho cụm C gồm các điểm A(1, 1), B(2, 4), C(6,1). Giả sử tâm của cụm là vector trung bình. Tâm của cụm là: ",
    options: [
      "mC = (3 ; 2)",
      "mC = (2 ; 3)",
      "mC = (2.5 ; 1.5)",
      "mC = (6 ; 1)"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 159: k-Mean phù hợp nhất với cụm có hình dạng nào sau đây:",
    options: [
      "Dạng hình cầu",
      "Cụm dài và mảnh",
      "Các cụm có các điểm phân bố ngẫu nhiên ",
      "Hình dạng bất kỳ"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 160: Phát biểu nào KHÔNG phải nhược điểm của k-mean:",
    options: [
      "Thuật toán khó cài đặt",
      "Không đảm bảo tối ưu toàn cục",
      "Khó phát hiện các loại cụm có hình dạng phức tạp và nhất là các dạng cụm không lồi ",
      "Cần xác định trước số cụm k"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 161: Thuật toán k-mean dừng khi:",
    options: [
      "Không thể gán (hoặc gán lại) từng điểm vào cụm khác ",
      "Số cụm sinh ra là k",
      "Tuỳ theo yêu cầu người dùng",
      "Khi tất cả các phần tử đã được gán vào k cụm "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 162: Hãy chọn phát biểu sai trong các phát biểu sau đây về thuật toán phân cụm k-mean: ",
    options: [
      "Phụ thuộc vào thứ tự các phần tử đưa vào phân cụm ",
      "Cần phải xác định trước số cụm cần sinh ra ",
      "k-mean phù hợp với các cụm có dạng hình cầu ",
      "Vector được chọn làm tâm của mỗi cụm là vector trung bình của cụm đó "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 163: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đơn (Single Linkage), sau khi gom x1 và x2 thành cụm C={x1, x2} thì khoảng cách giữa cụm C và x3 bằng bao nhiêu: ",
    image: "images/163.jpg",
    imageCaption: "",

    options: [
      "bằng 2",
      "bằng 3",
      "bằng 0",
      "bằng 9"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 164: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đơn (Single Linkage), sau khi gom x1 và x2 thành cụm C={x1, x2} thì khoảng cách giữa x3 và x4 bằng bao nhiêu: ",
    image: "images/164.jpg",
    imageCaption: "",
    options: [
      "bằng 3",
      "bằng 2",
      "bằng 0",
      "bằng 9"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 165: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự. Sử dụng thuật toán liên kết đầy đủ (Complete Linkage), sau khi gom x1 và x2 thành cụm C={x1, x2} thì khoảng cách giữa cụm C và x3 bằng bao nhiêu: ",
    image: "images/165.jpg",
    imageCaption: "",
    options: [
      "bằng 9",
      "bằng 3",
      "bằng 1",
      "bằng 2"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 166: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 3.5, các cụm sinh ra là ",
    image: "images/166.jpg",
    imageCaption: "",
    options: [
      "C1={x1,x2,x3,x4}; C2={x5}",
      "C1={x1,x2,x3}; C2={x4,x5}",
      "C1={x1,x2}; C2={x3,x4,x5}",
      "C1={x1,x2}; C2={x4,x5}; C3={x3}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 167: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 2.5, các cụm sinh ra là ",
    image: "images/167.jpg",
    imageCaption: "",
    options: [
      "C1={x1,x2,x3}; C2={x4}; C3={x5}",
      "C1={x1,x2,x3}; C2={x4,x5}",
      "C1={x1,x2}; C2={x3,x4,x5}",
      "C1={x1,x2}; C2={x4,x5}; C3={x3}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 168: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 1.5, các cụm sinh ra là ",
    image: "images/168.jpg",
    imageCaption: "",
    options: [
      "C1={x1,x2}; C2={x3}; C3={x4}; C4={x5}",
      "C1={x1,x2}; C2={x4,x5}; C3={x3}",
      "C1={x1,x2}; C2={x3,x4}; C3={x5}",
      "C1={x1}; C2={x2}; C3={x4,x5}; C4={x3}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 169: Cho sơ đồ ngưỡng không tương tự như hình vẽ. Cắt sơ đồ tại ngưỡng bằng 5, các cụm sinh ra là ",
    image: "images/169.jpg",
    imageCaption: "",
    options: [
      "C1={x1,x2,x3,x4,x5}",
      "C1={x1,x2}; C2={x3,x4,x5}",
      "C1={x1,x2}; C2={x3,x4}; C3={x5}",
      "C1={x1}; C2={x2}; C3={x4}; C4={x5}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 170: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đầy đủ (Complete Linkage), sau khi gom x1 và x2 thành cụm C={x1, x2} thì khoảng cách giữa x3 và x4 bằng bao nhiêu: ",
    image: "images/170.jpg",
    imageCaption: "",
    options: [
      "bằng 3",
      "bằng 2",
      "bằng 1",
      "bằng 9"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 171: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đơn (Single Linkage). Bước đầu tiên ta gom x1, x2, vào cụm C1, ma trận không tương tự P1 sinh ra là ma trận cấp mấy: ",
    image: "images/171.jpg",
    imageCaption: "",
    options: ["cấp 4", "cấp 5", "cấp 1", "cấp 3"],
    correctAnswer: 0
  },
  {
    question: "Câu 172: Kết quả của quá trình phân cụm phân cấp là:",
    options: [
      "Một sơ đồ ngưỡng tương tự (hoặc không tương tự)",
      "Một danh sách các cụm",
      "Một cây nhị phân biểu diễn quá trình gom cụm",
      "k cụm với k cho trước"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 173: Chọn phát biểu sai:",
    options: [
      "Thuật toán phân cụm phân cấp phụ thuộc vào trình tự đưa các phần tử vào phân cụm ",
      "Cắt sơ đồ ngưỡng tương tự hoặc không tương tự tại một ngưỡng nào đó, ta sẽ được danh sách các cụm ",
      "Single Linkage, Complete Linkage là 2 trường hợp đặc biệt của thuật toán phân cấp ",
      "Kết quả phân cụm phụ thuộc vào việc chọn đặc trưng, chọn độ đo gần gũi, chọn đại diện của cụm và chọn thuật toán phân cụm "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 174: Thuật toán Apriori : Ghép 2 tập mục có 3-tems với nhau để được  tập mục có 4-item. Các tập mục nào có thể ghép được với nhau : ",
    options: [
      "L1={abc}, L2={abd}",
      "L1={abc}, L2={aed}",
      "L1={abc}, L2={ebd}",
      "L1={gbc}, L2={abd}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 175: Thuật toán Apriori : Ghép 2 tập mục có 4-tems với nhau, ta sẽ được tập mục có bao nhiêu item : ",
    options: ["5-items", "6-items", "7-items", "8-items"],
    correctAnswer: 0
  },
  {
    question: "Câu 176: Thuật toán Apriori : Cho 2 tập mục L1={abcd}, L2={abck}. Ghép L1 và L2 với nhau thành tập mục L, ta được tập mục nào sau đây? ",
    options: ["L={abcdk}", "L={abc}", "L={dk}", "L={abck}"],
    correctAnswer: 0
  },
  {
    question: "Câu 177: Cho tập mục thường xuyên L={ABCDE}, giả sử tất cả các luật kết hợp sinh ra đều thỏa mãn điều kiện, hỏi có bao nhiêu luật kế hợp được sinh ra? ",
    options: ["Có 30 luật", "Có 20 luật", "Có 5 luật", "Có 32 luật"],
    correctAnswer: 0
  },
  {
    question: "Câu 178: FP-Tree: Có 2 đường đi từ gốc tới nút p là:  abcd:2 và abce:2. Cây điều kiện FP của nút p là: ",
    options: ["{abc:4}|p", "{abc:2}|p", "{abcde:4}|p", "{de:4}|p"],
    correctAnswer: 0
  },
  {
    question: "Câu 179: Cho các điểm A(1, 1), B(2, 1), C(4, 3), D(5, 4), E(0,0). Sử dụng thuật toán phân cụm k-mean để chia 5 điểm vào 2 cụm. Kết quả phân cụm là: ",
    options: [
      "C1={A, B, E}; C2={C, D}",
      "C1={A, B}; C2={C, D}",
      "C1={A, B, E}; C2={C, D, E}",
      "C1={A, E}; C2={B, C, D}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 180: Cho các điểm A(1, 1), B(2, 1), C(4, 3), D(5, 4), E(0,0). Sử dụng thuật toán phân cụm k-mean để chia 5 điểm vào 2 cụm. Cụm C1 được hình thành gồm 3 phần tử A, B, E. Vector trung bình (trọng tâm) của cụm là: ",
    options: ["mC1=(1, 2/3)", "mC1=(0, 2/3)", "mC1=(1, 3)", "mC1=(1, 2)"],
    correctAnswer: 0
  },
  {
    question: "Câu 181: Đường kính của cụm được định nghĩa là khoảng cách giữa 2 phần tử xa nhau nhất trong cùng 1 cụm. Cho 1 cụm gồm các phần tử C={x1, x2, x3, x4} với x1(10, 0), x2(1, 0), x3(6, 0), x4(4, 0) ",
    options: ["d=9", "d=8", "d=10", "d=2"],
    correctAnswer: 0
  },
  {
    question: "Câu 182: Khoảng cách giữa 2 cụm C1, C2 được định nghĩa là khoảng cách giữa 2 phần tử x thuộc C1 và y thuộc C2 sao khoảng cách giữa x và y là lớn nhất. Cho 2 cụm C1={x1, x2}, C2={x3, x4, x5}, với x1(0, 0), x2(1, 0), x3(6, 0), x4(4, 0), x5(3,0), khoảng cách giữa 2 cụm này là: ",
    options: ["d=6", "d=4", "d=2", "d=1"],
    correctAnswer: 0
  },
  {
    question: "Câu 183: Khoảng cách giữa 2 cụm C1, C2 được định nghĩa là khoảng cách giữa 2 phần tử x thuộc C1 và y thuộc C2 sao khoảng cách giữa x và y là bé nhất. Cho 2 cụm C1={x1, x2}, C2={x3, x4, x5}, với x1(0, 0), x2(1, 0), x3(6, 0), x4(4, 0), x5(3,0), khoảng cách giữa 2 cụm này là: ",
    options: ["d=2", "d=4", "d=6", "d=1"],
    correctAnswer: 0
  },
  {
    question: "Câu 184: Khoảng cách giữa 2 cụm C1, C2 được định nghĩa là giá trị trung bình của mọi khoảng cách giữa 2 phần tử  x thuộc C1 và y thuộc C2. Cho 2 cụm C1={x1, x2}, C2={x3, x4}, với x1(0, 0), x2(1, 0), x3(6, 0), x4(4, 0), khoảng cách giữa 2 cụm này là: ",
    options: ["d=4.5", "d=4.0", "d=6.0", "d=1.5"],
    correctAnswer: 0
  },
  {
    question: "Câu 185: Cho tập dữ liệu gồm m phần tử, mỗi phần tử là một vector trong không gian n chiều, cần phân tập này thành k cụm theo thuật toán k-mean. Điều kiện nào sau đây phải thỏa mãn trong mối quan hệ giữa m, n và k  ",
    options: [
    "m >= k",
    "m < k",
    "m = k + n",
    "k > m + n"],
    correctAnswer: 0
  },
  {
    question: "Câu 186: Trong thuật toán liên kết đơn sử dụng ma trận, cho ma trận không tương tự P0 cấp 5 x 5. Khi 2 cụm được trộn với nhau thành 1 cụm thì ma trận P1 có cấp là bao nhiêu? ",
    options: ["Cấp 4x4", "Cấp 3x3", "Cấp 5x5", "Cấp 2x2"],
    correctAnswer: 0
  },
  {
    question: "Câu 187: Trong thuật toán liên kết đơn sử dụng ma trận, ở một bước nào đó tập dữ liệu đang phân thành 4 cụm, vậy cần xây dựng ma trận không tương tự cấp mấy? ",
    options: ["Cấp 4x4", "Cấp 3x3", "Cấp 5x5", "Cấp 2x2"],
    correctAnswer: 0
  },
  {
    question: "Câu 188: Hoveland và Hind giới thiệu thuật toán CLS lần đầu tiên vào năm bao nhiêu?  ",
    options: [
      "Năm 50 của thế kỷ XX",
      "Năm 40 của thế kỷ XX",
      "Năm 60 của thế kỷ XX",
      "Năm 70 của thế kỷ XX"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 189: Kết quả của thuật toán CLS là đưa ra cây quyết định dựa trên:  ",
    options: [
      "Các mẫu mô tả quyết định",
      "Các ngày để quan tâm",
      "Các con số tính toán",
      "Tất cả đều sai"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 190: Thuật toán ID3 được cung cấp vào thời gian nào của thế kỷ XX ? ",
    options: ["Thập niên 70", "Thập niên 50", "Thập niên 60", "Thập niên 90"],
    correctAnswer: 0
  },
  {
    question: "Câu 191: Công thức để tính Information Gain của tập dữ liệu S và thuộc tính A là :  ",
    options: [
      "Gain(S,A)=Entropy(S)-Entropy(A)",
      "Gain(S,A)=Info(A)+Entropy(A)",
      "Gain(S,A)=Entropy(A)-Info(A)",
      "Gain(S,A)=Entropy(A)-Entropy(S)"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 192: Missing Data là:",
    options: [
      "Tập dữ liệu bị thiếu",
      "Là tập các dữ liệu sử dụng để phân cụm ",
      "Là tập dữ liệu bị nhiễu ",
      "Là tập các dữ liệu chứa các thông tin hữu ích "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 193: Noisy Data là:",
    options: [
      "Tập dữ liệu bị nhiễu",
      "Tập dữ liệu bị thiếu",
      "Là tập các dữ liệu chứa các thông tin dư thừa ",
      "Là các tập dữ liệu không nhiễu"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 194: Với công thức tính Gain thông thường không phù hợp với tình huống nào ? ",
    options: [
      "Với các thuộc tính có rất nhiều giá trị ",
      "Không phụ hợp với ba thuộc tính  ",
      "Không phù hợp với tập chỉ có duy nhất một mẫu ",
      "Mọi trường hợp đều phù hợp"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 195: Tập dữ liệu S gồm các thuộc tính A, B, C, D. Gain(S, A)=0.3, Gain(S,B)=0.6, Gain(S,C)=0.14, Gain(S,D)=0.99. Thuộc tính nào được chọn để phân nhánh? :",
    options: ["Thuộc tính D", "Thuộc tính A", "Thuộc tính B", "Thuộc tính C"],
    correctAnswer: 0
  },
  {
    question: "Câu 196: Tập dữ liệu S gồm các thuộc tính A, B, C, D. Entropy(A)=0.3, Entropy(B)=0.6, Entropy(C)=0.14, Entropy(D)=0.99. Thuộc tính nào được chọn để phân nhánh? ",
    options: ["Thuộc tính C", "Thuộc tính A", "Thuộc tính B", "Thuộc tính D"],
    correctAnswer: 0
  },
  {
    question: "Câu 197: Tiến trình Khai phá tri thức – KDD gồm các bước như sau: ",
    options: [
      "Lựa chọn dữ liệu, tiền xử lí dữ liệu, chuyển dạng, khai phá dữ liệu, trình diễn dữ liệu",
      "Lựa chọn, chuyển dạng, khai phá dữ liệu, tiền xử lí dữ liệu, trình diễn dữ liệu",
      "Lựa chọn, khai phá dữ liệu, trình diễn dữ liệu, tiền xử lí",
      "Lựa chọn, khai phá dữ liệu, trình diễn dữ liệu"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 198: Sự bùng nổ của dữ liệu trong những năm gần đây có nhiều nguyên nhân, trong đó có những nguyên nhân sau (chọn đáp án đúng nhất): ",
    options: [
      "Công nghệ phần cứng phát triển mạnh, năng lực số hóa của con người ngày càng cao, bùng nổ công nghệ mạng, tác nhân tạo mới dữ liệu ngày càng nhiều... ",
      "Khoa khọc kỹ thuật ngày càng tiến bộ, nguồn nhân lực ngành Công nghệ thông tin ngày càng đông, nhu cầu khai thác thông tin ngày càng nhiều... ",
      "Thông tin thu thập từ việc nghiên cứu các hành tinh, thông tin chống khủng bố, thông tin quảng cáo ngày càng nhiều... ",
      "Dữ liệu quảng cáo ngày càng nhiều, bùng nổ các mạng xã hội,... "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 199: Data Integration là:",
    options: [
      "Cách kết hợp dữ liệu tìm được từ các nguồn dữ liệu khác nhau ",
      "Tích hợp thông tin khách hàng phục vụ quá trình Data Mining ",
      "Phân chia dữ liệu phục vụ quá trình Data Mining ",
      "Là bước thực hiện sau khi đã tìm kiếm tri thức mới từ dữ liệu "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 200: Phát biểu sai về tiền xử lí dữ liệu là:",
    options: [
      "Dữ liệu sau tiền xử lí sẽ thành tri thức mới",
      "Không có dữ liệu tốt thì không có kết quả tốt",
      "Phân lớn công việc xây dựng một kho dữ liệu là trích chọn, làm sạch và chuyển đổi dữ liệu —Bill Inmon ",
      "Dữ liệu có chất lượng cao nếu như phù hợp với mục đích sử dụng trong điều hành, ra quyết định, và lập kế hoạch. "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 201: Các bài toán chính trong Tiền xử lí dữ liệu là:",
    options: [
      "Làm sạch dữ liệu, Tích hợp dữ liệu, Chuyển dạng dữ liệu, Rút gọn dữ liệu, Rời rạc dữ liệu",
      "Làm sạch dữ liệu, Tích hợp dữ liệu, Chuyển dạng dữ liệu, Rời rạc dữ liệu",
      "Phân lớp, Tìm luật kết hợp, Gom cụm",
      "Lựa chọn đặc trưng, Tìm thuật toán để Khai phá dữ liệu"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 202: Xếp thùng - Binning - là phương pháp rời rạc hóa đơn giản nhất. Phương pháp này gồm có: ",
    options: [
      "Phân hoạch cân bằng bề rộng Equal-width và Phân hoạch cân bằng theo chiều sâu Equal-depth ",
      "Xếp thùng theo chiều sâu và Xếp thùng làm trơn theo giá trị nhỏ nhất ",
      "Làm trơn theo giá trị lớn nhất và làm trơn theo giá trị nhỏ nhất ",
      "Làm trơn theo biên phải và làm trơn theo biên trái "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 203: Phương pháp Xếp thùng - Binning là phương pháp: ",
    options: [
      "Sắp xếp dữ liệu tăng dần và chia đều vào các thùng, sau đó sử dụng phương pháp làm trơn theo trung bình, theo biên, theo trung tuyến. ",
      "Chia đều dữ liệu vào các thùng, sau đó sử dụng phương pháp làm trơn theo trung bình, theo biên, theo trung tuyến. ",
      "Sắp xếp dữ liệu tăng dần và chia vào các thùng, mỗi thùng có số phần tử tùy ý, sau đó sử dụng phương pháp làm trơn theo trung bình, theo biên, theo trung tuyến. ",
      "Sắp xếp dữ liệu giảm dần và chia đều vào N thùng, loại bỏ các thùng không cần thiết "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 204: Cho tập dữ liệu được xếp theo giá: 4, 8, 9, 15, 21, 21, 24, 25, 26, 28, 29, 34. Chia tập dữ liệu trên thành 3 thùng. Kết quả chia thùng theo chiều sâu là: ",
    options: [
      "Bin 1: 4, 8, 9, 15; Bin 2: 21, 21, 24, 25; Bin 3: 26, 28, 29, 34",
      "Bin 1: 4, 4, 4, 4; Bin 2: 21, 21, 21, 21; Bin 3: 26, 26, 26, 26",
      "Bin 1: 4, 4, 4, 15; Bin 2: 21, 21, 25, 25; Bin 3: 26, 26, 26, 34",
      "Bin 1: 15, 15, 15, 15; Bin 2: 23, 23, 23, 23; Bin 3: 29, 29, 29, 29"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 205: Cho tập dữ liệu được xếp theo giá: 4, 8, 9, 15, 21, 21, 24, 25, 26, 28, 29, 34. Chia tập dữ liệu trên thành 3 thùng theo chiều sâu. Kết quả chia thùng làm trơn theo trung bình là: ",
    options: [
      "Bin 1: 9, 9, 9, 9; Bin 2: 23, 23, 23, 23; Bin 3: 29, 29, 29, 29",
      "Bin 1: 4, 4, 4, 4; Bin 2: 21, 21, 21, 21; Bin 3: 26, 26, 26, 26",
      "Bin 1: 4, 4, 4, 15; Bin 2: 21, 21, 25, 25; Bin 3: 26, 26, 26, 34",
      "Bin 1: 15, 15, 15, 15; Bin 2: 23, 23, 23, 23; Bin 3: 29, 29, 29, 29"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 206: Cho tập dữ liệu được xếp theo giá: 4, 8, 9, 15, 21, 21, 24, 25, 26, 28, 29, 34. Chia thành 3 thùng theo chiều sâu. Kết quả phương pháp chia thùnglàm trơn theo biên là: ",
    options: [
      "Bin 1: 4, 4, 4, 15; Bin 2: 21, 21, 25, 25; Bin 3: 26, 26, 26, 34",
      "Bin 1: 4, 4, 4, 4; Bin 2: 21, 21, 21, 21; Bin 3: 26, 26, 26, 26",
      "Bin 1: 9, 9, 9, 9; Bin 2: 23, 23, 23, 23; Bin 3: 29, 29, 29, 29",
      "Bin 1: 15, 15, 15, 15; Bin 2: 23, 23, 23, 23; Bin 3: 29, 29, 29, 29"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 207: Phương pháp xếp thùng phân hoạch cân bằng theo bề rộng là: ",
    options: [
      "Chia miền giá trị thành N đoạn có độ dài như nhau ",
      "Chia miền xác định thành N đoạn ‘’đều nhau về số lượng’’ các đoạn có xấp xỉ số ví dụ mẫu. ",
      "Lựa chọn số phần tử ngẫu nhiên và xếp và N thùng ",
      "Các phần tử có giá trị như nhau sẽ được xếp vào cùng 1 thùng "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 208: Trong quá trình Tiền xử lí dữ liệu người ta thường dùng một số phương pháp chuẩn hóa dữ liệu sau: ",
    options: [
      "Min-Max, z-Score, Tỷ lệ thập phân – decimal scale ",
      "2NF, 3NF, BCNF",
      "Đưa về hệ đếm thập phân, Hệ nhị phân, hệ Hecxa ",
      "Chuẩn hóa về dữ liệu văn bản, hình ảnh, âm thanh "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 209: Một số chiến lược rút gọn dữ liệu là: ",
    options: [
      "Tập  hợp khối dữ liệu, Giảm đa chiều – loại bỏ thuộc tính không quan trọng, Nén dữ liệu, Giảm tính số hóa – dữ liệu thành mô hình, Rời rạc hóa và sinh cây khái niệm",
      "Tìm kiếm thêm thông tin có ích, xây dựng cây quyết định, phân nhóm dữ liệu ",
      "Phân lớp dữ liệu, tìm đặc trưng của dữ liệu, loại bỏ nhiễu ",
      "Loại bỏ phần tử ngoại lai, tìm các dữ liệu quan trọng, đưa về mô hình toán học "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 210: Thuật toán k-means được sử dụng để:",
    options: [
      "Phân cụm tập dữ liệu thành k cụm ",
      "Phân cụm tập dữ liệu thành k tâm ",
      "Phân tập dữ liệu thành các cụm sao cho mỗi cụm có k phần tử ",
      "Phân cụm tập dữ liệu thành các cụm. "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 211: Công thức chuẩn hóa theo phương pháp Min-Max nào đúng: ",
    image: "images1/211.jpg",
    imageCaption: "",

    options: ["Đáp án A", "Đáp án B", "Đáp án C", "Đáp án D"],
    correctAnswer: 0
  },
  {
    question: "Câu 212: Công thức chuẩn hóa theo Tỷ lệ thập phân nào đúng: ",
    image: "images1/212.jpg",
    imageCaption: "",
    options: ["Đáp án A", "Đáp án B", "Đáp án C", "Đáp án D"],
    correctAnswer: 0
  },
  {
    question: "Câu 213: Cho miền giá trị từ 12000 đến 98000, Sử dụng phương pháp Min-Max để chuẩn hóa về đoạn [0.0 ; 1.0]. Giá trị 73000 được chuẩn hóa là:",
    options: ["0.716", "0.800", "0.500", "Giá trị khác"],
    correctAnswer: 0
  },
  {
    question: "Câu 214: Cho miền giá trị từ 120 đến 980, Sử dụng phương pháp Min-Max để chuẩn hóa về đoạn [0.0 ; 10]. Giá trị 550 được chuẩn hóa là: ",
    options: ["5.0", "8.0", "9.0", "Giá trị khác"],
    correctAnswer: 0
  },
  {
    question: "Câu 215: Cho miền giá trị của A từ -986 đến 917, Sử dụng phương pháp chuẩn hóa Tỷ lệ Thập phân– decimal scale, miền giá trị của A sau khi chuẩn hóa là:",
    options: [
      "-0.986 đến 0.917",
      "0.0 đến 1.0",
      "0.0 đến 9.17",
      "Giá trị khác"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 216: Cho giá trị của A là 1500, Sử dụng phương pháp chuẩn hóa Tỷ lệ Thập phân– decimal scale, giá trị của A sau khi chuẩn hóa là: ",
    options: ["0.15", "1.5", "0.015", "Giá trị khác"],
    correctAnswer: 0
  },
  {
    question: "Câu 217: Phát biểu nào đúng về Phương pháp phân tích thành phần chính (Principal Component Analysis-PCA): ",
    options: [
      "Chỉ áp dụng cho dữ liệu số và dùng khi số chiều vector lớn ",
      "Chỉ áp dụng cho dữ liệu văn bản và dùng khi số chiều vector lớn ",
      "Áp dụng cho mọi loại dữ liệu ",
      "Tìm đặc trưng quan trọng của tập dữ liệu "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 218: Phát biểu nào đúng về Phương pháp phân tích thành phần chính (Principal Component Analysis-PCA: ",
    options: [
      "Cho N vector dữ liệu k-chiều, tìm c (<= k) vector trực giao tốt nhất để trình diễn dữ liệu. Tập dữ liệu gốc được rút gọn thành N vector dữ liệu c chiều: c thành phần chính (chiều được rút gọn). Mỗi vector dữ liệu là tổ hợp tuyến tính của các vector thành phần chính. ",
      "Cho N vector dữ liệu k-chiều, tìm c (<= k) vector đại diện để trình diễn dữ liệu. Tập dữ liệu gốc được rút gọn thành N vector dữ liệu c chiều: c thành phần chính (chiều được rút gọn). Mỗi vector dữ liệu là tổ hợp tuyến tính của các vector thành phần chính. ",
      "Cho N vector dữ liệu k-chiều, tìm c (<= k) vector trực giao tốt nhất để trình diễn dữ liệu. Tập dữ liệu gốc được rút gọn thành N vector dữ liệu k chiều: k thành phần chính (chiều được rút gọn). Mỗi vector dữ liệu là tổ hợp tuyến tính của các vector thành phần chính. ",
      "Cho N vector dữ liệu k-chiều, tìm c (<= k) vector để trình diễn dữ liệu. Tập dữ liệu gốc được rút gọn thành 1 vector dữ liệu c chiều: c thành phần chính (chiều được rút gọn). Mỗi vector dữ liệu là tổ hợp tuyến tính của các vector thành phần chính. "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 219: Rời rạc hóa là:",
    options: [
      "Rút gọn số lượng giá trị của thuộc tính liên tục bằng cách chia miền giá trị của thuộc tính thành các đoạn. Nhãn đoạn sau đó được dùng để thay thế giá trị thực.",
      "Đưa dữ liệu về dạng số nhị phân",
      "Biểu diễn dữ liệu thành dạng dữ liệu không liên tục ",
      "Chuyển đổi dữ liệu sang dạng sóng điện từ "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 220: Cho L là tập mục thường xuyên, S là tập con của L thì với mọi tập con S’ của S ta có: ",
    options: [
      "Confidence(S'→L-S) ≤ Confidence(S→L-S)",
      "Confidence(S'→L-S) : Confidence(S→L-S)",
      "Confidence(S'→L-S) > Confidence(S→L-S)",
      "Không so sánh được Conference(S’-->L-S) và Conference(S-->L-S) "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 221: Cho X, Y là các tập mục, X là tập con của Y thì ta có: ",
    options: [
      "Support(X) ≥ Support(Y)",
      "Support(X) ≤ Support(Y)",
      "Support(X) = Support(Y)",
      "Không so sánh được Support(X) và Support(Y) "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 222: Cho X={A,B}, Y={A, B, C} là các tập mục, ta có: ",
    options: [
      "Support(X) ≥ Support(Y)",
      "Support(X) ≤ Support(Y)",
      "Support(X) = Support(Y)",
      "Không so sánh được Support(X) và Support(Y) "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 223: Cho X không là tập mục thường xuyên thì với mọi tập Y chứa X ta có kết luận: ",
    options: [
      "Y không là tập mục thường xuyên",
      "Y là tập mục thường xuyên",
      "X là tập mục thường xuyên",
      "Không thể kết luận được điều gì "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 224: Cho X ={A,B,C} là tập mục thường xuyên, Y={A, B} ta có kết luận: ",
    options: [
      "Y là tập mục thường xuyên",
      "Y không là tập mục thường xuyên",
      "C là tập mục thường xuyên",
      "X không là tập mục thường xuyên"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 225: Kết luận nào sau đây là sai :",
    options: [
      "Tập con của một tập mục thường xuyên KHÔNG là tập mục thường xuyên ",
      "Tập con của một tập mục thường xuyên là tập mục thường xuyên ",
      "Nếu luật kết hợp A-->BC thỏa mãn điều kiện của bài toán thì AB-->C cũng là luật kết hợp thỏa mãn điều kiện của bài toán ",
      "Cho tập mục X={X1, X2, …, Xn}. Nếu tất cả các mục Xi trong X đều không là tập mục thường xuyên thì mọi tập con Y của X cũng không là tập mục thường xuyên. "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 226: Cho X ={A, B} không là tập mục thường xuyên, Y = {A, B, C} ta có kết luận: ",
    options: [
      "Y không là tập mục thường xuyên",
      "Y là tập mục thường xuyên",
      "X là tập mục thường xuyên",
      "C không là tập mục thường xuyên"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 227: Cho X ={X1, X2, …, Xn } là tập các mục. Y là tập con của X. Nếu tất cả các mục Xi đều không là tập mục không thường xuyên thì ta có kết luận: ",
    options: [
      "Y không là tập mục thường xuyên",
      "Y là tập mục thường xuyên",
      "X là tập mục thường xuyên",
      "Tập X-Y là tập mục thường xuyên"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 228: Ý tưởng chính của thuật toán Apriori là: ",
    options: [
      "Tạo ra các tập phổ biến (thường xuyên) có 1 item, rồi tiếp đến là 2 items, 3 items... cho đến khi chúng ta tạo ra tập phổ biến của mọi kích thước. Mỗi tập item được tạo ra phải được tính toán độ hỗ trợ và độ tin cậy. Tập k-item được tạo ra từ tập k-1 items. Tạo danh sách các item dự kiến của tập k-items bằng cách hợp từng đôi một tập k-1 items có trong danh sách. ",
      "Tạo ra các tập phổ biến (thường xuyên) có 1 item, rồi tiếp đến là 2 items, 3 items... cho đến khi chúng ta tạo ra tập phổ biến của mọi kích thước. Tập k item được tạo ra từ tập k-1 items. Tạo danh sách các item dự kiến của tập k-items bằng cách hợp từng đôi một tập k-1 items có trong danh sách. Loại bỏ các tập item không thỏa độ hỗ trợ và độ tin cậy ",
      "Tạo bảng chứa các item phổ biến, loại bỏ các item không phổ biến. Giả sử có k item là ứng viên. Tính các tập mục mà mỗi mục có số lượng phần tử là tổ hợp chập 1, 2, 3, … k của k item. Loại bỏ các item không thỏa mãn độ hỗ trợ và độ tin cậy. ",
      "Lần lượt tạo ra danh sách các item dự kiến của tập k-items bằng cách hợp từng đôi một tập k-1 items có trong danh sách. Loại bỏ các tập item không thỏa độ hỗ trợ và độ tin cậy. "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 229: Cho tập mục thường xuyên X có độ dài k (k mục), từ tập X có thể sinh ra bao nhiêu luật kết hợp: ",
    options: [
      "2^k-2, không tính luật X   và   X ",
      "2^k không tính luật X   và   X ",
      "k luật",
      "Vô số luật kết hợp"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 230: Cho tập mục thường xuyên X={A, B, C}, từ tập X có thể sinh ra bao nhiêu luật kết hợp: ",
    options: [
      "6 luật, không tính luật X   và   X ",
      "8 luật, không tính luật X   và   X ",
      "3 luật",
      "1 luật"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 231:  Cho tập mục thường xuyên X={A, B, C, D}, từ tập X có thể sinh ra bao nhiêu luật kết hợp: ",
    options: [
      "14 luật, không tính luật X → ∅ và ∅ → X",
      "16 luật, không tính luật ∅ → X",
      "3 luật",
      "1 luật"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 232: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Sử dụng thuật toán Apriori, sau lần duyệt thứ hai, danh sách L2 chứa các tập mục thường xuyên có 2-item được tạo ra là: ",
    image: "images1/232.jpg",
    imageCaption: "",

    options: [
      "L2={{A,C}, {B,C}, {B,E}, {C,E}}",
      "L2={{A,D}, {B,D}, {B,E}, {C,E}}",
      "L2={{B,C}, {B,E}, {C,E}}",
      "L2={{A,C}, {C,E}}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 233: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%).Sử dụng thuật toán Apriori, sau lần duyệt thứ hai, các tập mục có 2-item được không thỏa mãn độ hỗ trợ tối thiểu là:   ",
    image: "images1/233.jpg",
    imageCaption: "",

    options: [
      "{A,B} và {A,E}",
      "{A,B} và {A,D}",
      "{A,C} và {B,C}",
      "{A,C} và {B,E}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 234: Cho CSDL giao dịch như hình vẽ với Min_Support = 2 (50%). Sử dụng thuật toán Apriori, cho L2={{A,C}, {B,C}, {B,E}, {C,E}} là danh sách các tập mục thường xuyên có 2-item. Giả sử tập mục {A,B} và {A,E} không là tập mục thường xuyên. Sau khi ghép các tập mục thường xuyên 2-item với nhau để được danh sách L3 chứa các tập mục thường xuyên có 3-item, L3 là:  ",
    image: "images1/234.jpg",
    imageCaption: "",
    options: [
      "L3={{B, C, E}}",
      "L3={{A,B,C} và {A,C,E}}",
      "L3={{A,C,E} và {B,C,E}}",
      "L3={{A,B,C}}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 235: Cho tập ví dụ học như bảng. Theo phân lớp Bayes thì bộ X={Outlook=’Overcast’, Temperature=’Cold’, Humidity=’Normal’, Wind=’Strong’} thuộc lớp nào:  ",
    image: "images1/235.jpg",
    imageCaption: "",
    options: [
      "Lớp Play Ball = 'Yes'",
      "Lớp Play Ball = 'No'",
      "Không phân lớp được",
      "Lớp Outlook = 'Overcast'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 236: Cho tập ví dụ học như bảng. Theo 	phân 	lớp 	Bayes 	thì 	bộ 	X={Outlook=’Rain’, 	Temperature=’Cold’, Humidity=’High’, Wind=’Weak’} thuộc lớp nào:   ",
    image: "images1/236.jpg",
    imageCaption: "",
    options: [
      "Lớp Play Ball = 'No'",
      "Lớp Play Ball = 'Yes'",
      "Không phân lớp được",
      "Lớp Outlook = 'Rain'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 237: Cho tập ví dụ học như bảng. Theo 	phân 	lớp 	Bayes 	thì 	bộ 	X={Outlook=’Rain’, 	Temperature=’Cold’, Humidity=’Normal’, Wind=’Weak’} thuộc lớp nào:  ",
    image: "images1/237.jpg",
    imageCaption: "",
    options: [
      "Lớp Play Ball = 'No'",
      "Lớp Play Ball = 'Yes'",
      "Không phân lớp được",
      "Lớp Outlook = 'Rain'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 238: Cho tập ví dụ học như bảng. Theo 	phân 	lớp 	Bayes 	thì 	bộ 	X={Outlook=’Sunny’, 	Temperature=’Cold’, Humidity=’Normal’, Wind=’Strong’} thuộc lớp nào. ",
    image: "images1/238.jpg",
    imageCaption: "",
    options: [
      "Lớp Play Ball = 'Yes'",
      "Lớp Play Ball = 'No'",
      "Không phân lớp được",
      "Lớp Outlook = 'Rain'"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 239: Cho FP-Tree như hình vẽ, cây điều kiện FP của nút f là: ",
    image: "images1/239.jpg",
    imageCaption: "",
    options: [
      "Cây rỗng",
      "{f:4}",
      "{f:4, c:1}",
      "{f:3, c:3, a:3}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 240: Cho FP-Tree như hình vẽ, cây điều kiện FP của nút C là: ",
    image: "images1/240.jpg",
    imageCaption: "",
    options: [
      "Cây rỗng",
      "{f:4}",
      "{f:4, c:1}",
      "{f:1, c:1}"
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 241: Cho FP-Tree như hình vẽ, cây điều kiện FP của nút a là: ",
    image: "images1/241.jpg",
    imageCaption: "",
    options: [
      "{f:4, c:3}",
      "{f:3, c:3}",
      "{f:4, c:3, a:3}",
      "{f:3, c:3, a:3}"
    ],
    correctAnswer: 1
  },
  {
    question: "Câu 242: Cho đồ thị như hình vẽ, đồ thị trên biểu diễn gì ? ",
    image: "images1/242.jpg",
    imageCaption: "",
    options: [
      "So sánh Thời gian thực thi với số lượng giao dịch",
      "So sánh giữa thời gian thực thi của FP-Growth và Apriori theo số lượng giao dịch",
      "So sánh 2 thuật toán FP-Growth và Apriori",
      "Mối quan hệ giữa FP-Growth và Apriori"
    ],
    correctAnswer: 1
  },
  {
    question: "Câu 243: Cho đồ thị như hình vẽ. Từ đồ thị ta thấy: ",
    image: "images1/243.jpg",
    imageCaption: "",
    options: [
      "Với cùng số lượng giao dịch như nhau, thời gian thực thi của thuật toán FP-Growth luôn nhiều hơn thời gian thực thi của thuật toán Apriori ",
      "Với cùng số lượng giao dịch như nhau, thời gian thức thi thuật toán FP-Growth luôn ít hơn thời gian thực thi thuật toán Apriori ",
      "Thuật toán Apriori thực hiện nhanh hơn thuật toán FP-Growth ",
      "Hai thuật toán FP-Growth và Apriori đều thức thi với thời gian rất nhỏ. "
    ],
    correctAnswer: 0
  },
  {
    question: "Câu 244: Cho đồ thị như hình vẽ. Nhận xét nào sau đây là sai: ",
    image: "images1/244.jpg",
    imageCaption: "",
    options: [
      "Với cùng số lượng giao dịch như nhau, thời gian thức thi thuật toán FP-Growth luôn ít hơn thời gian thực thi thuật toán Apriori ",
      "Thuật toán Apriori thực hiện nhanh hơn thuật toán FP-Growth ",
      "Khi số lượng giao tác rất nhỏ, thời gian thực thi của 2 thuật toán FP-Growth và Apriori là tương đương ",
      "Thuật toán FP-Growth thực hiện nhanh hơn thuật toán Apriori "
    ],
    correctAnswer: 1
  },
  {
    question: "Câu 245: Cho đồ thị như hình vẽ, đồ thị trên biểu diễn gì ? ",
    image: "images1/245.jpg",
    imageCaption: "",
    options: [
      "So sánh giữa Thời gian thực thi (tính bằng giây) của 2 thuật toán FP-Growth và Apriori trên 2 Database D1 và Database D2 ",
      "So sánh giữa Thời gian thực thi (tính bằng giây) của 2 thuật toán FP-Growth và Apriori theo ngưỡng của độ hỗ trợ trên 2 Database D1 và Database D2 ",
      "So sánh 2 thuật toán FP-Growth và Apriori theo ngưỡng độ tin cậy ",
      "Mối quan hệ giữa 2 thuật toán FP-Growth và Apriori "
    ],
    correctAnswer: 1
  },
  {
    question: "Câu 246: Cho đồ thị như hình vẽ. Từ đồ thị ta thấy: ",
    image: "images1/246.jpg",
    imageCaption: "",
    options: [
      "Với cùng ngưỡng của độ hỗ trợ, thời gian thực thi của thuật toán FP-Growth luôn nhiều hơn thời gian thực thi của thuật toán Apriori ",
      "Với cùng ngưỡng của độ hỗ trợ, thời gian thức thi thuật toán FP-Growth luôn ít hơn thời gian thực thi thuật toán Apriori ",
      "Thuật toán Apriori thực hiện nhanh hơn thuật toán FP-Growth ",
      "Hai thuật toán FP-Growth và Apriori đều thức thi với thời gian rất nhỏ. "
    ],
    correctAnswer: 1
  },
  {
    question: "Câu 247: Cho đồ thị như hình vẽ. Nhận xét nào sau đây là sai: ",
    image: "images2/247.jpg",
    imageCaption: "",   
    options: [
      "Với cùng ngưỡng độ hỗ trợ, thời gian thức thi thuật toán FP-Growth luôn ít hơn thời gian thực thi thuật toán Apriori ",
      "Thuật toán Apriori thực hiện nhanh hơn thuật toán FP-Growth ",
      "Khi số ngưỡng của độ hỗ trợ rất lớn, thời gian thực thi của 2 thuật toán FP-Growth và Apriori là tương đương ",
      "Thuật toán FP-Growth thực hiện nhanh hơn thuật toán Apriori "
    ],
    correctAnswer: 1
  },
  {
    question: "Câu 248: Hãy cho biết đáp án nào trong các đáp án trên là đúng: ",
    image: "images2/248.jpg",
    imageCaption: "", 
    options: ["Đáp án B", "Đáp án A", "Đáp án C", "Đáp án D"],
    correctAnswer: 1
  },
  {
    question: "Câu 249: Hãy cho biết đáp án nào trong các đáp án trên là đúng: ",
   image: "images2/249.jpg",
    imageCaption: "", 
    options: ["Đáp án B", "Đáp án A", "Đáp án C", "Đáp án D"],
    correctAnswer: 1
  },
  {
    question: "Câu 250: Hãy cho biết đáp án nào trong các đáp án trên là đúng:",
   image: "images2/250.jpg",
    imageCaption: "", 
    options: ["Đáp án B", "Đáp án A", "Đáp án C", "Đáp án D"],
    correctAnswer: 1
  },
  {
    question: "Câu 251: Cho tập ví dụ học như bảng. X={Outlook=’Sunny’, Temperature=’Cold’, Humidity=’Normal’, Wind=’Strong’} là một mẫu. Thuộc Wind có các giá trị ‘Weak’ và ‘Strong’, với:  ",
   image: "images2/251.jpg",
    imageCaption: "", 
    options: [
      "P(Weak|Yes)=2/3; P(Weak|No)=1/3; P(Strong|Yes)=2/3; P(Strong|No)=2/3",
      "P(Weak|Yes)=2/3; P(Weak|No)=2/3; P(Strong|Yes)=1/3; P(Strong|No)=1/3",
      "P(Weak|Yes)=1/3; P(Weak|No)=2/3; P(Strong|Yes)=3/3; P(Strong|No)=1/3",
      "P(Weak|Yes)=2/3; P(Weak|No)=0/3; P(Strong|Yes)=1/3; P(Strong|No)=1/3"
    ],
    correctAnswer: 1
  },
  {
    question: "Câu 252: Cho tập ví dụ học như bảng. X={Outlook=’Sunny’, Temperature=’Cold’, Humidity=’Normal’, Wind=’Strong’}là một mẫu. Thuộc Humidity có các giá trị ‘Normal’ và ‘High’, với:  ",
   image: "images2/252.jpg",
    imageCaption: "", 
    options: [
      "P(Normal|Yes)=2/3; P(Normal|No)=1/3; P(High|Yes)=1/3; P(High|No)=2/3",
      "P(Normal|Yes)=1/3; P(Normal|No)=3/3; P(High|Yes)=0/3; P(High|No)=2/3",
      "P(Normal|Yes)=3/3; P(Normal|No)=1/3; P(High|Yes)=0/3; P(High|No)=2/3",
      "P(Normal|Yes)=0/3; P(Normal|No)=2/3; P(High|Yes)=3/3; P(High|No)=2/3"
    ],
    correctAnswer: 2
  },
  {
    question: "Câu 253: Cho 3 điểm x, y, z. Độ đo khoảng cách d phải thỏa mãn các điều kiện nào: ",
    options: [
      "d(x,y)>0 ; d(x,y)=d(y,x) ; d(x,y) =0 ; d(x,y)<=d(x,z)+d(z,y) ",
      "d(x,y)>=0 ; d(x,y)<=d(x,z)+d(z,y) ",
      "d(x,y)>=0 ; d(x,y)=d(y,x) ; d(x,x) =0 ; d(x,y)<=d(x,z)+d(z,y) ",
      "d(x,y)>=0 ; d(x,x) =0 ; d(x,y)<=d(x,z)+d(z,y) "
    ],
    correctAnswer: 2
  },
  {
    question: "Câu 254: Khi chọn đại diện cho cụm, có thể chọn các đại diện sau: ",
    options: [
      "Đại diện điểm, đại diện siêu cầu",
      "Đại diện siêu phẳng, đại diện điểm",
      "Đại diện điểm, đại diện siêu phẳng và đại diện siêu cầu ",
      "Đại diện siêu cầu và siêu phẳng"
    ],
    correctAnswer: 2
  },
  {
    question: "Câu 255: Có N phần tử cần chia thành m cụm, mỗi cụm có ít nhất 1 phần tử. Gọi S(N,m) là số cách chia N phần tử vào m cụm. Công thức nào sau đây cho ta tổng số cách chia cụm: ",
    options: [
      "S(N, m) = m.S(N, m) + S(N - 1, m - 1) ",
      "S(N, m) = N.S(N - 1, m) + S(N - 1, m - 1) ",
      "S(N, m) = m.S(N - 1, m) + S(N - 1, m - 1) ",
      "S(N, m) = S(N - 1, m) + m.S(N - 1, m - 1) "
    ],
    correctAnswer: 2
  },
  {
    question: "Câu 256: Có N phần tử cần chia thành 2 cụm, mỗi cụm có ít nhất 1 phần tử. Công thức nào sau đây cho ta tổng số cách chia cụm: ",
    options: ["S(N,2) = 2^N - 1 ", "S(N,2) = 2^(N-1) ", "S(N,2) = 2^(N-1) - 1 ", "S(N,2) = 2^N "],
    correctAnswer: 2
  },
  {
    question: "Câu 257: Có N phần tử cần chia thành 2 cụm, mỗi cụm có ít nhất 1 phần tử. Công thức nào sau đây cho ta tổng số cách chia cụm: ",
    options: ["S(N,2) = 2^N - 1 ", "S(N,2) = 2^(N-1) ", "S(N,2) = 2^(N-1) - 1 ", "S(N,2) = 2^N "],
    correctAnswer: 2
  },
  {
    question: "Câu 258: Có 4 phần tử cần chia thành 2 cụm, mỗi cụm có ít nhất 1 phần tử. Hỏi có bao nhiêu cách chia cụm: ",
    options: ["16 cách", "15 cách", "7 cách", "1 cách"],
    correctAnswer: 2
  },
  {
    question: "Câu 259: Có 5 phần tử cần chia thành 2 cụm, mỗi cụm có ít nhất 1 phần tử. Hỏi có bao nhiêu cách chia cụm: ",
    options: ["7 cách", "32 cách", "15 cách", "1 cách"],
    correctAnswer: 2
  },
  {
    question: "Câu 260: Hãy chọn định nghĩa đúng về Ma trận không tương tự: ",
    options: [
      "Cho tập X gồm N phần tử {x1, x2, …, xN}, mỗi phần tử là một vector. Ma trận không tương tự P(X) là ma trận cấp N  N mà phần tử nằm ở vị trí (i, j) có giá trị là i*j ",
      "Cho tập X gồm N phần tử {x1, x2, …, xN}, mỗi phần tử là một vector. Ma trận không tương tự P(X) là ma trận cấp N  N mà phần tử nằm ở vị trí (i, j) bằng 0 ",
      "Cho tập X gồm N phần tử {x1, x2, …, xN}, mỗi phần tử là một vector. Ma trận không tương tự P(X) là ma trận cấp N  N mà phần tử nằm ở vị trí (i, j) bằng độ không tương tự d(xi,xj) giữa hai vector xi và xj. ",
      "Cho tập X gồm N phần tử {x1, x2, …, xN}, mỗi phần tử là một vector. Ma trận không tương tự P(X) là ma trận cấp N  N mà phần tử nằm trên đường chéo chính bằng 0, các phần tử khác có giá trị bất kỳ "
    ],
    correctAnswer: 2
  },
  {
    question: "Câu 261: Phát biểu nào sau đây không đúng về Ma trận không tương tự: ",
    options: [
      "Là ma trận đối xứng qua đường chéo chính ",
      "Là ma trận cho biết độ không tương tự giữa 2 phần tử bất kỳ ",
      "Các phần tử nằm trên đường chéo chính bằng có giá trị 0 ",
      "Là ma trận mà các phần tử trên đường chéo chính bằng 1 "
    ],
    correctAnswer: 3
  },
  {
    question: "Câu 262: Sơ đồ gần gũi là:",
    options: [
      "Sơ đồ gần gũi là một sơ đồ xét mức độ gần gũi ở đó hai cụm được trộn với nhau tạo thành sơ đồ hình cây ",
      "Sơ đồ gần gũi là một sơ đồ xét mức độ gần gũi biểu diễn mối quan hệ giữa các phần tử trong quá trình phân cụm ",
      "Sơ đồ gần gũi là sơ đồ không tương tự ",
      "Sơ đồ gần gũi là một sơ đồ xét mức độ gần gũi ở đó hai cụm được trộn với nhau ở lần đầu tiên. Khi sử dụng độ đo không tương tự (tương tự), sơ đồ gần gũi được gọi là một sơ đồ không tương tự (tương tự). "
    ],
    correctAnswer: 3
  },
  {
    question: "Câu 263: Độ phức tạp của thuật toán k-Means là:",
    options: [
      "O(n+k+t) trong đó n là số phần tử cần phân cụm, k là số cụm, t là số lần lặp ",
      "O(n^2) trong đó n là số phần tử cần phân cụm ",
      "O(n) trong đó n là số phần tử cần phân cụm ",
      "O(n*k*t) trong đó n là số phần tử cần phân cụm, k là số cụm, t là số lần lặp "
    ],
    correctAnswer: 3
  },
  {
    question: "Câu 264: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như  sau: Sử dụng thuật toán liên kết đầy đủ (Complete Linkage). Bước đầu tiên ta gom x1, x2 hình vào cụm C1={x1, x2}, bước thứ 2 ta sẽ thực hiện thế nào: ",
    image: "images2/264.jpg",
    imageCaption: "",

    options: ["Gom x3 với C1", "Gom x4 với C1", "Gom x3 với x5", "Gom x3 với x4"],
    correctAnswer: 3
  },
  {
    question: "Câu 265: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đơn (Single Linkage). Bước đầu tiên ta gom x1, x2, vào cụm C1, bước thứ 2 ta sẽ gom hai cụm nào với nhau: ",
    image: "images2/265.jpg",
    imageCaption: "",

    options: ["Gom x3 với x4", "Gom x4 với C1", "Gom x3 với x5", "Gom x3 với C1"],
    correctAnswer: 3
  },
  {
    question: "Câu 266: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đơn (Single Linkage). Bước đầu tiên ta gom x1, x2 vào cụm C1, ma trận không tương tự P1 được sinh ra có dòng thứ nhất liệt kê từ trái sang phải là: ",
   image: "images2/266.jpg",
    imageCaption: "",

    options: ["0;9;8;7", "1;9;6;5", "1;2;6;6", "0;2;6;5"],
    correctAnswer: 3
  },
  {
    question: "Câu 267: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đầy đủ (Complete Linkage). Bước đầu tiên ta gom x1, x2 vào cụm C1, ma trận không tương tự P1 được sinh ra có dòng thứ nhất liệt kê từ trái sang phải là:  ",
     image: "images2/267.jpg",
    imageCaption: "",
    options: ["0;2;6;5", "1;9;6;5", "1;2;6;5", "0;9;8;7"],
    correctAnswer: 3
  },
  {
    question: "Câu 268: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đơn (Single Linkage). Bước đầu tiên gom x1 và x2 hình thành cụm C1={x1, x2}; bước 2 ta gom C1 và x3 hình thành cụm C2={x1, x2, x3}. Hỏi bước thứ 3, ta sẽ gom thế nào:  ",
    image: "images2/268.jpg",
    imageCaption: "",
    options: ["Gom x4 với C1", "Gom x4 với x5", "Gom x5 với C1", "Gom x4 với C2"],
    correctAnswer: 3
  },
  {
    question: "Câu 269: Cho tập dữ liệu X={x1, x2, x3, x4, x5} và ma trận không tương tự như hình. Sử dụng thuật toán liên kết đầy đủ (Complete Linkage). Bước đầu tiên gom x1 và x2 hình thành cụm C1={x1, x2}; bước 2 ta gom x3 và x4 hình thành cụm C2={x3, x4}. Hỏi bước thứ 3, ta sẽ gom thế nào: ",
   image: "images2/269.jpg",
    imageCaption: "",
    options: ["Gom x3 với C2", "Gom x3 với x5", "Gom x5 với C2", "Gom C1 với x5"],
    correctAnswer: 3
  },
  {
    question: "Câu 270: Phát biểu nào đúng về thuật toán liên kết đơn: ",
    options: [
      "Chọn 2 cụm gần nhau nhất Ci, Cj để trộn với nhau thành cụm Cp. Khoảng cách giữa cụm mới Cp và các cụm còn lại Cq là d(Cp,Cq)=Max{d(Ci,Cq); d(Cj,Cq)} ",
      "Chọn 2 cụm xa nhau nhất Ci, Cj để trộn với nhau thành cụm Cp. Khoảng cách giữa cụm mới Cp và các cụm còn lại Cq là d(Cp,Cq)=Min{d(Ci,Cq); d(Cj,Cq)} ",
      "Chọn 2 cụm xa nhau nhất Ci, Cj để trộn với nhau thành cụm Cp. Khoảng cách giữa  ",
      "Chọn 2 cụm cụm gần nhau nhất Ci, Cj để trộn với nhau thành cụm Cp. Khoảng cách giữa cụm mới Cp và các cụm còn lại Cq là d(Cp,Cq)=Min{d(Ci,Cq); d(Cj,Cq)} cụm mới Cp và các cụm còn lại Cq là d(Cp,Cq)=Max{d(Ci,Cq); d(Cj,Cq)} "
    ],
    correctAnswer: 0
  }

];

        // ========== BIẾN TOÀN CỤC ==========
        let questions = [...allQuestions];
        let currentQuestionIndex = 0;
        let userAnswers = new Array(allQuestions.length).fill(null);
        let userAnswersChecked = new Array(allQuestions.length).fill(false);
        let score = 0;
        
        // Cài đặt
        let autoNextEnabled = true;
        let shuffleQuestionsEnabled = false;
        let shuffleOptionsEnabled = false;
        let retryWrongMode = false;
        
        // Lưu thứ tự xáo trộn
        let questionShuffleMaps = new Array(allQuestions.length).fill(null);
        let displayToOriginalQuestionMap = Array.from({length: allQuestions.length}, (_, i) => i);
        
        // Chế độ làm lại câu sai
        let wrongQuestionsIndices = [];
        let currentRetryIndex = 0;

        // ========== DOM ELEMENTS ==========
        const quizContent = document.getElementById('quiz-content');
        const currentQuestionEl = document.getElementById('current-question');
        const answeredCountEl = document.getElementById('answered-count');
        const scoreEl = document.getElementById('score');
        const progressPercentEl = document.getElementById('progress-percent');
        const progressFillEl = document.getElementById('progress-fill');
        const progressTextEl = document.getElementById('progress-text');
        
        const prevBtn = document.getElementById('prev-btn');
        const nextBtn = document.getElementById('next-btn');
        const resultBtn = document.getElementById('result-btn');
        
        const autoNextBtn = document.getElementById('auto-next-btn');
        const shuffleQuestionsBtn = document.getElementById('shuffle-questions-btn');
        const shuffleOptionsBtn = document.getElementById('shuffle-options-btn');
        const retryWrongBtn = document.getElementById('retry-wrong-btn');
        
        const resultContainer = document.getElementById('result-container');
        const finalScoreEl = document.getElementById('final-score');
        const scoreTextEl = document.getElementById('score-text');
        const statCorrectEl = document.getElementById('stat-correct');
        const statWrongEl = document.getElementById('stat-wrong');
        const statSkippedEl = document.getElementById('stat-skipped');
        const statPercentageEl = document.getElementById('stat-percentage');
        
        const restartBtn = document.getElementById('restart-btn');
        const reviewBtn = document.getElementById('review-btn');

        // ========== HÀM TIỆN ÍCH ==========
        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };

        const updateStats = () => {
            const answeredCount = userAnswers.filter(a => a !== null).length;
            const correctCount = userAnswers.reduce((count, answer, index) => {
                if (answer !== null && answer === allQuestions[index].correctAnswer) {
                    return count + 1;
                }
                return count;
            }, 0);
            
            // Hiển thị khác nhau tùy chế độ
            if (retryWrongMode) {
                currentQuestionEl.textContent = `${currentRetryIndex + 1}/${wrongQuestionsIndices.length}`;
            } else {
                currentQuestionEl.textContent = `${currentQuestionIndex + 1}/${questions.length}`;
            }
            
            answeredCountEl.textContent = `${answeredCount}/${allQuestions.length}`;
            scoreEl.textContent = correctCount;
            
            const progressPercent = Math.round((answeredCount / allQuestions.length) * 100);
            progressPercentEl.textContent = `${progressPercent}%`;
            progressFillEl.style.width = `${progressPercent}%`;
            progressTextEl.textContent = `${progressPercent}%`;
        };

        const getWrongQuestions = () => {
            const wrongIndices = [];
            
            userAnswers.forEach((answer, originalIndex) => {
                if (answer !== null && answer !== allQuestions[originalIndex].correctAnswer) {
                    const displayIndex = displayToOriginalQuestionMap.indexOf(originalIndex);
                    if (displayIndex !== -1) {
                        wrongIndices.push(displayIndex);
                    }
                }
            });
            
            return wrongIndices;
        };

        // ========== HIỂN THỊ CÂU HỎI (ĐÃ SỬA ĐỂ HỖ TRỢ HÌNH ẢNH) ==========
        const displayQuestion = (displayIndex) => {
            const originalIndex = displayToOriginalQuestionMap[displayIndex];
            const question = questions[displayIndex];
            
            // Tạo bản đồ ánh xạ đáp án
            let optionsToDisplay = [...question.options];
            let displayToOriginalOptionMap = {};
            
            if (shuffleOptionsEnabled) {
                if (!questionShuffleMaps[originalIndex]) {
                    questionShuffleMaps[originalIndex] = shuffleArray([0, 1, 2, 3]);
                }
                
                const shuffled = questionShuffleMaps[originalIndex];
                optionsToDisplay = shuffled.map(i => question.options[i]);
                
                shuffled.forEach((originalIdx, displayIdx) => {
                    displayToOriginalOptionMap[displayIdx] = originalIdx;
                });
            } else {
                [0, 1, 2, 3].forEach((originalIdx, displayIdx) => {
                    displayToOriginalOptionMap[displayIdx] = originalIdx;
                });
                questionShuffleMaps[originalIndex] = null;
            }
            
            // Tạo HTML cho các đáp án
            let optionsHTML = '';
            optionsToDisplay.forEach((option, displayIndex) => {
                const originalOptionIndex = displayToOriginalOptionMap[displayIndex];
                const isSelected = userAnswers[originalIndex] === originalOptionIndex;
                const isCorrect = originalOptionIndex === question.correctAnswer;
                const isChecked = userAnswersChecked[originalIndex];
                
                let optionClass = 'option';
                if (isSelected) optionClass += ' selected';
                if (isChecked && isCorrect) optionClass += ' correct';
                if (isChecked && isSelected && !isCorrect) optionClass += ' incorrect';
                
                const optionLabel = String.fromCharCode(65 + displayIndex);
                
                optionsHTML += `
                    <div class="${optionClass}" data-original-index="${originalOptionIndex}">
                        <div class="option-label">${optionLabel}</div>
                        <div class="option-text">${option}</div>
                        <div class="status-icon">
                            ${isChecked && isCorrect ? '<i class="fas fa-check"></i>' : ''}
                            ${isChecked && isSelected && !isCorrect ? '<i class="fas fa-times"></i>' : ''}
                        </div>
                    </div>
                `;
            });
            
            // Tạo HTML cho nội dung câu hỏi (HỖ TRỢ CẢ HÌNH ẢNH VÀ CODE)
            let contentHTML = '';
            
            // Thêm hình ảnh nếu có
            if (question.image) {
                contentHTML += `
                    <div class="question-content">
                        ${question.question}
                    </div>
                    <img src="${question.image}" alt="Hình minh họa" class="question-image">
                    ${question.imageCaption ? `<div class="image-caption">${question.imageCaption}</div>` : ''}
                `;
            } 
            // Thêm code nếu có (và không có hình ảnh)
            else if (question.content) {
                contentHTML = `
                    <div class="question-content">
                        ${question.question}
                    </div>
                    <div class="code-container">
                        ${highlightJavaCode(question.content)}
                    </div>
                `;
            } 
            // Nếu không có hình ảnh và code
            else {
                contentHTML = `
                    <div class="question-content">
                        ${question.question}
                    </div>
                `;
            }
            
            // Tạo HTML cho toàn bộ câu hỏi
            const questionHTML = `
                <div class="question-container">
                    <div class="question-header">
                        <div class="question-number">
                            <i class="fas fa-question-circle"></i>
                            Câu hỏi số ${displayIndex + 1}
                            ${retryWrongMode ? 
                                `<span class="retry-mode-badge">
                                    <i class="fas fa-exclamation-circle"></i> Làm lại câu sai (${currentRetryIndex + 1}/${wrongQuestionsIndices.length})
                                </span>` : 
                                ''}
                        </div>
                        <div style="color: #6c757d; font-size: 0.9rem;">
                            Chọn một đáp án đúng
                        </div>
                    </div>
                    
                    ${contentHTML}
                    
                    <div class="options-grid">
                        ${optionsHTML}
                    </div>
                    
                    ${userAnswersChecked[originalIndex] ? `
                        <div class="feedback">
                            <h4><i class="fas fa-lightbulb"></i> Giải thích</h4>
                            <div style="margin-top: 10px; padding: 10px; background: ${userAnswers[originalIndex] === question.correctAnswer ? '#d4edda' : '#f8d7da'}; border-radius: 5px;">
                                <i class="fas ${userAnswers[originalIndex] === question.correctAnswer ? 'fa-check-circle' : 'fa-times-circle'}"></i>
                                ${userAnswers[originalIndex] === question.correctAnswer ? 
                                    '<strong>Chính xác!</strong> Bạn đã trả lời đúng.' : 
                                    `<strong>Chưa chính xác.</strong> Đáp án đúng là: ${String.fromCharCode(65 + question.correctAnswer)}`}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
            
            quizContent.innerHTML = questionHTML;
            
            // Thêm sự kiện click cho các đáp án
            document.querySelectorAll('.option').forEach(option => {
                option.addEventListener('click', () => {
                    if (!userAnswersChecked[originalIndex]) {
                        const originalOptionIndex = parseInt(option.dataset.originalIndex);
                        handleAnswer(originalIndex, originalOptionIndex);
                    }
                });
            });
            
            // Cập nhật trạng thái nút điều hướng
            if (retryWrongMode) {
                prevBtn.disabled = currentRetryIndex === 0;
                nextBtn.disabled = currentRetryIndex === wrongQuestionsIndices.length - 1;
            } else {
                prevBtn.disabled = displayIndex === 0;
                nextBtn.disabled = displayIndex === questions.length - 1;
            }
            
            const answeredCount = userAnswers.filter(a => a !== null).length;
            resultBtn.style.display = answeredCount === allQuestions.length ? 'flex' : 'none';
            
            updateStats();
        };

        // ========== XỬ LÝ TRẢ LỜI ==========
        const handleAnswer = (originalQuestionIndex, answerIndex) => {
            userAnswers[originalQuestionIndex] = answerIndex;
            userAnswersChecked[originalQuestionIndex] = true;
            
            const isCorrect = answerIndex === allQuestions[originalQuestionIndex].correctAnswer;
            
            // Trong chế độ làm lại câu sai
            if (retryWrongMode) {
                if (isCorrect) {
                    // Nếu trả lời đúng trong chế độ làm lại
                    const displayIndex = displayToOriginalQuestionMap.indexOf(originalQuestionIndex);
                    const wrongIndex = wrongQuestionsIndices.indexOf(displayIndex);
                    
                    if (wrongIndex !== -1) {
                        wrongQuestionsIndices.splice(wrongIndex, 1);
                        
                        // Nếu đã hết câu sai
                        if (wrongQuestionsIndices.length === 0) {
                            alert('🎉 Chúc mừng! Bạn đã làm lại tất cả các câu sai thành công!');
                            toggleRetryWrongMode();
                            return;
                        }
                        
                        // Điều chỉnh currentRetryIndex
                        if (currentRetryIndex >= wrongQuestionsIndices.length) {
                            currentRetryIndex = 0;
                        }
                    }
                }
                
                // Cập nhật điểm số ngay lập tức
                score = userAnswers.reduce((count, answer, index) => {
                    if (answer !== null && answer === allQuestions[index].correctAnswer) {
                        return count + 1;
                    }
                    return count;
                }, 0);
            }
            
            const displayIndex = displayToOriginalQuestionMap.indexOf(originalQuestionIndex);
            displayQuestion(displayIndex);
            
            // Tự động chuyển câu
            if (autoNextEnabled) {
                setTimeout(() => {
                    if (retryWrongMode && wrongQuestionsIndices.length > 0) {
                        currentRetryIndex++;
                        if (currentRetryIndex < wrongQuestionsIndices.length) {
                            currentQuestionIndex = wrongQuestionsIndices[currentRetryIndex];
                            displayQuestion(currentQuestionIndex);
                        } else {
                            currentRetryIndex = 0;
                            currentQuestionIndex = wrongQuestionsIndices[0];
                            displayQuestion(currentQuestionIndex);
                        }
                    } else if (!retryWrongMode && currentQuestionIndex < questions.length - 1) {
                        currentQuestionIndex++;
                        displayQuestion(currentQuestionIndex);
                    }
                }, 1500);
            }
        };

        // ========== ĐIỀU KHIỂN ==========
        const goToPrevQuestion = () => {
            if (retryWrongMode) {
                if (currentRetryIndex > 0) {
                    currentRetryIndex--;
                    currentQuestionIndex = wrongQuestionsIndices[currentRetryIndex];
                    displayQuestion(currentQuestionIndex);
                }
            } else {
                if (currentQuestionIndex > 0) {
                    currentQuestionIndex--;
                    displayQuestion(currentQuestionIndex);
                }
            }
        };

        const goToNextQuestion = () => {
            if (retryWrongMode) {
                if (currentRetryIndex < wrongQuestionsIndices.length - 1) {
                    currentRetryIndex++;
                    currentQuestionIndex = wrongQuestionsIndices[currentRetryIndex];
                    displayQuestion(currentQuestionIndex);
                }
            } else {
                if (currentQuestionIndex < questions.length - 1) {
                    currentQuestionIndex++;
                    displayQuestion(currentQuestionIndex);
                }
            }
        };

        const showResults = () => {
            let correct = 0;
            let wrong = 0;
            let skipped = 0;
            
            userAnswers.forEach((answer, originalIndex) => {
                if (answer === null) {
                    skipped++;
                } else if (answer === allQuestions[originalIndex].correctAnswer) {
                    correct++;
                } else {
                    wrong++;
                }
            });
            
            const percentage = Math.round((correct / allQuestions.length) * 100);
            
            finalScoreEl.textContent = `${correct}/${allQuestions.length}`;
            statCorrectEl.textContent = correct;
            statWrongEl.textContent = wrong;
            statSkippedEl.textContent = skipped;
            statPercentageEl.textContent = `${percentage}%`;
            
            let evaluation = '';
            if (percentage >= 90) {
                evaluation = '🎉 Xuất sắc! Bạn thực sự am hiểu Lập Trình Mạng!';
            } else if (percentage >= 70) {
                evaluation = '👍 Rất tốt! Kiến thức của bạn khá vững vàng.';
            } else if (percentage >= 50) {
                evaluation = '✅ Khá ổn! Bạn nên ôn tập thêm một chút.';
            } else if (percentage >= 30) {
                evaluation = '📚 Cần cố gắng! Hãy dành thời gian ôn tập nhiều hơn.';
            } else {
                evaluation = '💪 Đừng nản! Hãy bắt đầu ôn tập lại từ đầu.';
            }
            
            scoreTextEl.textContent = evaluation;
            
            document.querySelector('.question-container')?.remove();
            resultContainer.classList.add('show');
        };

        const restartQuiz = () => {
            currentQuestionIndex = 0;
            userAnswers = new Array(allQuestions.length).fill(null);
            userAnswersChecked = new Array(allQuestions.length).fill(false);
            score = 0;
            
            questionShuffleMaps = new Array(allQuestions.length).fill(null);
            displayToOriginalQuestionMap = Array.from({length: allQuestions.length}, (_, i) => i);
            
            // Reset chế độ làm lại
            retryWrongMode = false;
            wrongQuestionsIndices = [];
            currentRetryIndex = 0;
            
            // Reset cài đặt
            shuffleOptionsEnabled = false;
            shuffleOptionsBtn.classList.remove('active');
            shuffleOptionsBtn.innerHTML = '<i class="fas fa-list-ol"></i><span>Đảo đáp án</span>';
            
            shuffleQuestionsEnabled = false;
            shuffleQuestionsBtn.classList.remove('active');
            shuffleQuestionsBtn.innerHTML = '<i class="fas fa-random"></i><span>Đảo câu hỏi</span>';
            
            autoNextEnabled = true;
            autoNextBtn.classList.add('active');
            autoNextBtn.innerHTML = '<i class="fas fa-bolt"></i><span>Tự chuyển câu (BẬT)</span>';
            
            // Reset nút làm lại
            retryWrongBtn.innerHTML = '<i class="fas fa-redo-alt"></i><span>Làm lại câu sai</span>';
            retryWrongBtn.classList.remove('active');
            retryWrongBtn.style.background = '#dc3545';
            
            resultContainer.classList.remove('show');
            resultBtn.style.display = 'none';
            
            questions = [...allQuestions];
            
            displayQuestion(currentQuestionIndex);
        };

        const reviewAnswers = () => {
            let reviewHTML = '<div class="question-container">';
            reviewHTML += '<h2 style="margin-bottom: 30px;"><i class="fas fa-list-ol"></i> Chi Tiết Bài Làm</h2>';
            
            displayToOriginalQuestionMap.forEach((originalIndex, displayIndex) => {
                const q = allQuestions[originalIndex];
                const userAnswer = userAnswers[originalIndex];
                const isCorrect = userAnswer === q.correctAnswer;
                const hasAnswer = userAnswer !== null;
                
                reviewHTML += `
                    <div style="margin-bottom: 25px; padding: 20px; border: 2px solid ${isCorrect ? '#28a745' : '#dc3545'}; border-radius: 10px; background: ${isCorrect ? '#d4edda20' : '#f8d7da20'}">
                        <div style="font-weight: bold; margin-bottom: 10px; color: #2c3e50;">
                            Câu ${displayIndex + 1}: ${q.question}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Đáp án của bạn:</strong> ${hasAnswer ? String.fromCharCode(65 + userAnswer) : 'Chưa trả lời'}
                            ${hasAnswer ? ` <span style="color: ${isCorrect ? '#28a745' : '#dc3545'}">(${isCorrect ? 'Đúng' : 'Sai'})</span>` : ''}
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Đáp án đúng:</strong> ${String.fromCharCode(65 + q.correctAnswer)}
                        </div>
                    </div>
                `;
            });
            
            reviewHTML += '</div>';
            quizContent.innerHTML = reviewHTML;
            resultContainer.classList.remove('show');
            
            const backBtn = document.createElement('button');
            backBtn.className = 'btn';
            backBtn.style.cssText = 'background: #6c757d; color: white; margin: 20px auto; display: block;';
            backBtn.innerHTML = '<i class="fas fa-arrow-left"></i> Quay lại kết quả';
            backBtn.onclick = showResults;
            quizContent.appendChild(backBtn);
        };

        // ========== TOGGLE SETTINGS ==========
        const toggleAutoNext = () => {
            autoNextEnabled = !autoNextEnabled;
            autoNextBtn.classList.toggle('active', autoNextEnabled);
            autoNextBtn.innerHTML = autoNextEnabled ? 
                '<i class="fas fa-bolt"></i><span>Tự chuyển câu (BẬT)</span>' : 
                '<i class="fas fa-bolt"></i><span>Tự chuyển câu (TẮT)</span>';
        };

        const toggleShuffleQuestions = () => {
            shuffleQuestionsEnabled = !shuffleQuestionsEnabled;
            shuffleQuestionsBtn.classList.toggle('active', shuffleQuestionsEnabled);
            
            if (shuffleQuestionsEnabled) {
                const shuffledIndices = shuffleArray([...Array(allQuestions.length).keys()]);
                displayToOriginalQuestionMap = shuffledIndices;
                questions = shuffledIndices.map(i => allQuestions[i]);
                
                shuffleQuestionsBtn.innerHTML = '<i class="fas fa-random"></i><span>Đảo câu hỏi (BẬT)</span>';
            } else {
                displayToOriginalQuestionMap = Array.from({length: allQuestions.length}, (_, i) => i);
                questions = [...allQuestions];
                
                shuffleQuestionsBtn.innerHTML = '<i class="fas fa-random"></i><span>Đảo câu hỏi (TẮT)</span>';
            }
            
            currentQuestionIndex = 0;
            displayQuestion(currentQuestionIndex);
        };

        const toggleShuffleOptions = () => {
            shuffleOptionsEnabled = !shuffleOptionsEnabled;
            shuffleOptionsBtn.classList.toggle('active', shuffleOptionsEnabled);
            shuffleOptionsBtn.innerHTML = shuffleOptionsEnabled ? 
                '<i class="fas fa-list-ol"></i><span>Đảo đáp án (BẬT)</span>' : 
                '<i class="fas fa-list-ol"></i><span>Đảo đáp án (TẮT)</span>';
            
            if (shuffleOptionsEnabled) {
                allQuestions.forEach((_, index) => {
                    if (!questionShuffleMaps[index]) {
                        questionShuffleMaps[index] = shuffleArray([0, 1, 2, 3]);
                    }
                });
            } else {
                questionShuffleMaps.fill(null);
            }
            
            displayQuestion(currentQuestionIndex);
        };

        const toggleRetryWrongMode = () => {
            const wrongQuestions = getWrongQuestions();
            
            if (!retryWrongMode) {
                // Bật chế độ làm lại
                if (wrongQuestions.length === 0) {
                    alert('Bạn không có câu nào trả lời sai để làm lại!');
                    return;
                }
                
                retryWrongMode = true;
                wrongQuestionsIndices = [...wrongQuestions];
                currentRetryIndex = 0;
                
                // XÓA HOÀN TOÀN ĐÁP ÁN CŨ CỦA CÁC CÂU SAI
                wrongQuestionsIndices.forEach(displayIndex => {
                    const originalIndex = displayToOriginalQuestionMap[displayIndex];
                    // Xóa đáp án đã chọn
                    userAnswers[originalIndex] = null;
                    // Đánh dấu là chưa kiểm tra
                    userAnswersChecked[originalIndex] = false;
                });
                
                // Cập nhật lại điểm số sau khi xóa đáp án cũ
                score = userAnswers.reduce((count, answer, index) => {
                    if (answer !== null && answer === allQuestions[index].correctAnswer) {
                        return count + 1;
                    }
                    return count;
                }, 0);
                
                // Đổi giao diện nút
                retryWrongBtn.innerHTML = '<i class="fas fa-times"></i><span>Thoát chế độ làm lại</span>';
                retryWrongBtn.classList.add('active');
                retryWrongBtn.style.background = '#6c757d';
                
                // Đi đến câu sai đầu tiên
                currentQuestionIndex = wrongQuestionsIndices[0];
                displayQuestion(currentQuestionIndex);
                
                // Thông báo
                alert(`🎯 Bật chế độ làm lại câu sai\n\nBạn có ${wrongQuestions.length} câu sai cần ôn tập.\nĐáp án cũ đã được xóa để bạn có thể làm lại từ đầu.`);
                
                // Cập nhật lại thống kê
                updateStats();
                
            } else {
                // Tắt chế độ làm lại
                retryWrongMode = false;
                wrongQuestionsIndices = [];
                currentRetryIndex = 0;
                
                // Khôi phục giao diện nút
                retryWrongBtn.innerHTML = '<i class="fas fa-redo-alt"></i><span>Làm lại câu sai</span>';
                retryWrongBtn.classList.remove('active');
                retryWrongBtn.style.background = '#dc3545';
                
                // Quay về câu đầu tiên
                currentQuestionIndex = 0;
                displayQuestion(currentQuestionIndex);
                
                alert('Đã thoát chế độ làm lại câu sai.');
            }
        };

        // ========== KHỞI TẠO ==========
        const init = () => {
            displayQuestion(currentQuestionIndex);
            
            // Thêm sự kiện cho các nút
            prevBtn.addEventListener('click', goToPrevQuestion);
            nextBtn.addEventListener('click', goToNextQuestion);
            resultBtn.addEventListener('click', showResults);
            
            autoNextBtn.addEventListener('click', toggleAutoNext);
            shuffleQuestionsBtn.addEventListener('click', toggleShuffleQuestions);
            shuffleOptionsBtn.addEventListener('click', toggleShuffleOptions);
            retryWrongBtn.addEventListener('click', toggleRetryWrongMode);
            
            restartBtn.addEventListener('click', restartQuiz);
            reviewBtn.addEventListener('click', reviewAnswers);
            
            // Thêm phím tắt
            document.addEventListener('keydown', (e) => {
                switch(e.key) {
                    case 'ArrowLeft':
                        if (!prevBtn.disabled) goToPrevQuestion();
                        break;
                    case 'ArrowRight':
                    case ' ':
                        if (!nextBtn.disabled) goToNextQuestion();
                        break;
                    case '1':
                    case '2':
                    case '3':
                    case '4':
                        const options = document.querySelectorAll('.option');
                        const optionIndex = parseInt(e.key) - 1;
                        if (optionIndex >= 0 && optionIndex < options.length) {
                            if (options[optionIndex]) {
                                options[optionIndex].click();
                            }
                        }
                        break;
                }
            });
        };

        init();
    </script>
</body>

</html>